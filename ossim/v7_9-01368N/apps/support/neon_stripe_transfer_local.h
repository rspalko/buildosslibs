/*****************************************************************************/
// File: neon_stripe_transfer_local.h [scope = APPS/SUPPORT]
// Version: Kakadu, V7.9
// Author: David Taubman
// Last Revised: 8 January, 2017
/*****************************************************************************/
// Copyright 2001, David Taubman, The University of New South Wales (UNSW)
// The copyright owner is Unisearch Ltd, Australia (commercial arm of UNSW)
// Neither this copyright statement, nor the licensing details below
// may be removed from this file or dissociated from its contents.
/*****************************************************************************/
// Licensee: Open Systems Integration; Inc
// License number: 01368
// The licensee has been granted a NON-COMMERCIAL license to the contents of
// this source file.  A brief summary of this license appears below.  This
// summary is not to be relied upon in preference to the full text of the
// license agreement, accepted at purchase of the license.
// 1. The Licensee has the right to install and use the Kakadu software and
//    to develop Applications for the Licensee's own use.
// 2. The Licensee has the right to Deploy Applications built using the
//    Kakadu software to Third Parties, so long as such Deployment does not
//    result in any direct or indirect financial return to the Licensee or
//    any other Third Party, which further supplies or otherwise uses such
//    Applications.
// 3. The Licensee has the right to distribute Reusable Code (including
//    source code and dynamically or statically linked libraries) to a Third
//    Party, provided the Third Party possesses a license to use the Kakadu
//    software, and provided such distribution does not result in any direct
//    or indirect financial return to the Licensee.
/******************************************************************************
Description:
   Finds SIMD implementations to accelerate the conversion and transfer of
data between the line buffers generated by `kdu_multi_synthesis' or
`kdu_multi_analysis' and the (possibly interleaved) application-supplied
sample buffers supplied to `kdu_stripe_decompressor::pull_stripe' or
`kdu_stripe_compressor::push_stripe'.  This file provides macros to
arbitrate the selection of suitable SIMD functions, if they exist, for
ARM processors equipped with the NEON vector processing unit.  The actual
SIMD functions themselves appear within "neon_stripe_transfer.cpp".
******************************************************************************/
#ifndef NEON_STRIPE_TRANSFER_LOCAL_H
#define NEON_STRIPE_TRANSFER_LOCAL_H
#include "kdu_arch.h"

namespace kd_supp_simd {
  using namespace kdu_core;


/* ========================================================================= */
/*               SIMD functions used by `kdu_stripe_compressor'              */
/* ========================================================================= */

#  define NEON_INT16_FROM_UINT8_ILV1(_func,_width)
#  define NEON_INT16_FROM_UINT8_ILV3(_func,_width)
#  define NEON_INT16_FROM_UINT8_ILV4(_func,_width)

#  define NEON_FLOATS_FROM_UINT8_ILV1(_func,_width)
#  define NEON_FLOATS_FROM_UINT8_ILV3(_func,_width)
#  define NEON_FLOATS_FROM_UINT8_ILV4(_func,_width)

#  define NEON_INT16_FROM_INT16_ILV1(_func,_width)
#  define NEON_INT32_FROM_INT16_ILV1(_func,_width)
#  define NEON_FLOATS_FROM_INT16_ILV1(_func,_width)

#  define NEON_FLOATS_FROM_FLOATS_ILV1(_func,_width)
//----------------------------------------------------------------------------


#if (defined KDU_NEON_INTRINSICS) && (!defined KDU_NO_NEON)
//----------------------------------------------------------------------------
extern void neoni_int16_from_uint8_ilv1(kdu_int16 **, kdu_byte *,
                                        int, int, int, bool, bool);
#undef NEON_INT16_FROM_UINT8_ILV1
#define NEON_INT16_FROM_UINT8_ILV1(_func,_width) \
  if ((kdu_neon_level > 0) && (_width > 32)) \
    _func = (kdsc_simd_transfer_func) neoni_int16_from_uint8_ilv1
//----------------------------------------------------------------------------
extern void neoni_int16_from_uint8_ilv3(kdu_int16 **, kdu_byte *,
                                        int, int, int, bool, bool);
#undef NEON_INT16_FROM_UINT8_ILV3
#define NEON_INT16_FROM_UINT8_ILV3(_func,_width) \
  if ((kdu_neon_level > 0) && (_width > 16)) \
    _func = (kdsc_simd_transfer_func) neoni_int16_from_uint8_ilv3
//----------------------------------------------------------------------------
extern void neoni_int16_from_uint8_ilv4(kdu_int16 **, kdu_byte *,
                                        int, int, int, bool, bool);
#undef NEON_INT16_FROM_UINT8_ILV4
#define NEON_INT16_FROM_UINT8_ILV4(_func,_width) \
  if ((kdu_neon_level > 0) && (_width > 16)) \
    _func = (kdsc_simd_transfer_func) neoni_int16_from_uint8_ilv4
//----------------------------------------------------------------------------
extern void neoni_int16_from_int16_ilv1(kdu_int16 **, kdu_int16 *,
                                        int, int, int, bool, bool);
#undef NEONI_INT16_FROM_INT16_ILV1
#define NEONI_INT16_FROM_INT16_ILV1(_func,_width) \
  if ((kdu_neon_level > 0) && (_width > 32)) \
    _func = (kdsc_simd_transfer_func) neoni_int16_from_int16_ilv1
//----------------------------------------------------------------------------
extern void neoni_floats_from_int16_ilv1(float **, kdu_int16 *,
                                         int, int, int, bool, bool);
#undef NEON_FLOATS_FROM_INT16_ILV1
#define NEON_FLOATS_FROM_INT16_ILV1(_func,_width) \
  if ((kdu_neon_level > 0) && (_width > 32)) \
    _func = (kdsc_simd_transfer_func) neoni_floats_from_int16_ilv1
//----------------------------------------------------------------------------
#endif // !KDU_NO_NEON


#define KDSC_FIND_SIMD_TRANSFER_FUNC(_func, _buf_type, _shorts, \
                      _sample_gap, _width, _prec, _tgt_prec, _absolute) \
  /* NB: last 4 args are identical to those passed to the transfer func. */ \
  { \
    _func = NULL; /* Until proven otherwise. */ \
    if (_sample_gap == 1) \
      { \
        if (_buf_type == KDSC_BUF8) \
          { \
            if (_shorts) \
              { /* Convert fixed point or reversible ints to bytes. */ \
                NEON_INT16_FROM_UINT8_ILV1(_func,_width); \
              } \
            else if (!_absolute) \
              { /* Convert floating point to bytes. */ \
                NEON_FLOATS_FROM_UINT8_ILV1(_func,_width); \
              } \
          } \
        else if (_buf_type == KDSC_BUF16) \
          { \
            if (_shorts) \
              { /* Convert words to words, allowing left or right shifts. */ \
                NEON_INT16_FROM_INT16_ILV1(_func,_width); \
              } \
            else if (!_absolute) \
              { /* Convert floating point to words. */ \
                NEON_FLOATS_FROM_INT16_ILV1(_func,_width); \
              } \
            else \
              { /* Convert 32-bit ints to words, with possible rightshift. */ \
                NEON_INT32_FROM_INT16_ILV1(_func,_width); \
              } \
          } \
        else if (_buf_type == KDSC_BUF_FLOAT) \
          { \
            if (!_absolute) \
              NEON_FLOATS_FROM_FLOATS_ILV1(_func,_width); \
          } \
      } \
    else if (_sample_gap == 3) \
      { \
        if (_buf_type == KDSC_BUF8) \
          { \
            if (_shorts) \
              { /* Convert fixed point or reversible ints to bytes. */ \
                NEON_INT16_FROM_UINT8_ILV3(_func,_width); \
              } \
            else if (!_absolute) \
             { /* Convert floating point to bytes. */ \
               NEON_FLOATS_FROM_UINT8_ILV3(_func,_width); \
             } \
          } \
      } \
    else if (_sample_gap == 4) \
      { \
        if (_buf_type == KDSC_BUF8) \
          { \
            if (_shorts) \
              { /* Convert fixed point or reversible ints to bytes. */ \
                NEON_INT16_FROM_UINT8_ILV4(_func,_width); \
              } \
            else if (!_absolute) \
             { /* Convert floating point to bytes. */ \
               NEON_FLOATS_FROM_UINT8_ILV4(_func,_width); \
             } \
          } \
      } \
  }


/* ========================================================================= */
/*              SIMD functions used by `kdu_stripe_decompressor'             */
/* ========================================================================= */

#  define NEON_INT16_TO_UINT8_ILV1(_func,_width)
#  define NEON_INT16_TO_UINT8_ILV3(_func,_width)
#  define NEON_INT16_TO_UINT8_ILV4(_func,_width)

#  define NEON_FLOATS_TO_UINT8_ILV1(_func,_width)
#  define NEON_FLOATS_TO_UINT8_ILV3(_func,_width)
#  define NEON_FLOATS_TO_UINT8_ILV4(_func,_width)

#  define NEON_INT16_TO_INT16_ILV1(_func,_width)
#  define NEON_INT32_TO_INT16_ILV1(_func,_width)
#  define NEON_FLOATS_TO_INT16_ILV1(_func,_width)

#  define NEON_FLOATS_TO_FLOATS_ILV1(_func,_width)
//----------------------------------------------------------------------------

  
#if (defined KDU_NEON_INTRINSICS) && (!defined KDU_NO_NEON)
//----------------------------------------------------------------------------
extern void neoni_int16_to_uint8_ilv1(kdu_byte *, kdu_int16 **,
                                      int, int, int, bool, bool, int);
#undef NEON_INT16_TO_UINT8_ILV1
#define NEON_INT16_TO_UINT8_ILV1(_func,_width) \
  if ((kdu_neon_level > 0) && (_width > 32)) \
    _func = (kdsd_simd_transfer_func) neoni_int16_to_uint8_ilv1
//----------------------------------------------------------------------------
extern void neoni_int16_to_uint8_ilv3(kdu_byte *, kdu_int16 **,
                                      int, int, int, bool, bool, int);
#undef NEON_INT16_TO_UINT8_ILV3
#define NEON_INT16_TO_UINT8_ILV3(_func,_width) \
  if ((kdu_neon_level > 0) && (_width > 16)) \
    _func = (kdsd_simd_transfer_func) neoni_int16_to_uint8_ilv3
//----------------------------------------------------------------------------
extern void neoni_int16_to_uint8_ilv4(kdu_byte *, kdu_int16 **,
                                      int, int, int, bool, bool, int);
#undef NEON_INT16_TO_UINT8_ILV4
#define NEON_INT16_TO_UINT8_ILV4(_func,_width) \
  if ((kdu_neon_level > 0) && (_width > 16)) \
    _func = (kdsd_simd_transfer_func) neoni_int16_to_uint8_ilv4
//----------------------------------------------------------------------------
extern void neoni_int16_to_int16_ilv1(kdu_int16 *, kdu_int16 **,
                                      int, int, int, bool, bool, int);
#undef NEON_INT16_TO_INT16_ILV1
#define NEON_INT16_TO_INT16_ILV1(_func,_width) \
  if ((kdu_neon_level > 0) && (_width > 32)) \
    _func = (kdsd_simd_transfer_func) neoni_int16_to_int16_ilv1
//----------------------------------------------------------------------------
extern void neoni_floats_to_int16_ilv1(kdu_int16 *, float **,
                                       int, int, int, bool, bool, int);
#undef NEON_FLOATS_TO_INT16_ILV1
#define NEON_FLOATS_TO_INT16_ILV1(_func,_width) \
  if ((kdu_neon_level > 0) && (_width > 16)) \
    _func = (kdsd_simd_transfer_func) neoni_floats_to_int16_ilv1
//----------------------------------------------------------------------------
#endif // !KDU_NO_NEON

#define KDSD_FIND_SIMD_TRANSFER_FUNC(_func, _buf_type, _shorts, \
                       _sample_gap, _width, _prec, _orig_prec, _absolute) \
  /* NB: last 4 args are identical to those passed to the transfer func. */ \
  { \
    _func = NULL; /* Until proven otherwise. */ \
    if (_sample_gap == 1) \
      { \
        if (_buf_type == KDSD_BUF8) \
          { \
            if (_shorts) \
              { /* Convert fixed point or reversible ints to bytes. */ \
                NEON_INT16_TO_UINT8_ILV1(_func,_width); \
              } \
            else if (!_absolute) \
              { /* Convert floating point to bytes. */ \
                NEON_FLOATS_TO_UINT8_ILV1(_func,_width); \
              } \
          } \
        else if (_buf_type == KDSD_BUF16) \
          { \
            if (_shorts) \
              { /* Convert words to words, allowing left or right shifts. */ \
                NEON_INT16_TO_INT16_ILV1(_func,_width); \
              } \
            else if (!_absolute) \
              { /* Convert floating point to words. */ \
                NEON_FLOATS_TO_INT16_ILV1(_func,_width); \
              } \
            else \
              { /* Convert 32-bit ints to words. */ \
                NEON_INT32_TO_INT16_ILV1(_func,_width); \
              } \
          } \
        else if (_buf_type == KDSD_BUF_FLOAT) \
          { \
            if (!_absolute) \
              NEON_FLOATS_TO_FLOATS_ILV1(_func,_width); \
          } \
      } \
    else if (_sample_gap == 3) \
      { \
        if (_buf_type == KDSD_BUF8) \
          { \
            if (_shorts) \
              { /* Convert fixed point or reversible ints to bytes. */ \
                NEON_INT16_TO_UINT8_ILV3(_func,_width); \
              } \
            else if (!_absolute) \
             { /* Convert floating point to bytes. */ \
               NEON_FLOATS_TO_UINT8_ILV3(_func,_width); \
             } \
          } \
      } \
    else if (_sample_gap == 4) \
      { \
        if (_buf_type == KDSD_BUF8) \
          { \
            if (_shorts) \
              { /* Convert fixed point or reversible ints to bytes. */ \
                NEON_INT16_TO_UINT8_ILV4(_func,_width); \
              } \
            else if (!_absolute) \
             { /* Convert floating point to bytes. */ \
               NEON_FLOATS_TO_UINT8_ILV4(_func,_width); \
             } \
          } \
      } \
  }
  
} // namespace kd_supp_simd

#endif // NEON_STRIPE_TRANSFER_LOCAL_H
