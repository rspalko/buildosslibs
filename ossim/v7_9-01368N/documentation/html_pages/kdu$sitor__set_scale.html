<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (kdu_region_compositor::set_scale) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
.function-text { padding-left: 80pt;
                 text-indent: -60pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#B4DCB4">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$sitor__wai$m_headers.html"> prev </A>||<A HREF="kdu$sitor__fin$mal_scale.html"> next </A>|</P>
<H1><A NAME="ToP">kdu_region_compositor::set_scale</A></H1>
<DIR><DIR><H3><EM><U>Java:</U> Kdu_region_compositor.Set_scale</EM></H3></DIR></DIR>
<P CLASS="function-text"><B>void</B> set_scale(
<B>bool</B>&nbsp;transpose,
<B>bool</B>&nbsp;vflip,
<B>bool</B>&nbsp;hflip,
<B>float</B>&nbsp;scale,
<B>float</B>&nbsp;rendering_scale_adjustment=1.0f)</P>
<DIR><DIR><P CLASS="function-text"><EM><U>Java:</U> public native void Set_scale(
boolean&nbsp;transpose,
boolean&nbsp;vflip,
boolean&nbsp;hflip,
float&nbsp;scale,
float&nbsp;rendering_scale_adjustment)</EM></P></DIR></DIR>
<P><A HREF="kdu$sitor.html">Go to class description.</A></P>

<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
Sets any rotation, flipping or transposition to be
performed, and the scale at which the image is to be
composed. The interpretation of the 
<A HREF="kdu$sitor__set_scale.html#transpose">transpose</A>, 
<A HREF="kdu$sitor__set_scale.html#hflip">hflip</A> and 
<A HREF="kdu$sitor__set_scale.html#vflip">vflip</A> arguments is identical to that described in conjunction
with the 
<A HREF="kdu$tream__cha$ppearance.html">kdu_codestream::change_appearance</A> function.
</P><P>
 From KDU-7.6, this function allows you to set two
scale factors simultaneously, which is very useful
for interactive rendering applications that are computation-constrained,
but may be a little confusing. The 
<A HREF="kdu$sitor__set_scale.html#scale">scale</A> parameter determines the significance of all dimensional
and location information returned by and/or passed
into virtually all of the region-compositor's member
functions. However, the actual composited buffer returned
by 
<A HREF="kdu$sitor__get$on_buffer.html">get_composition_buffer</A> can be rendered at a different scale (usually smaller,
to save computational effort during interactive re-rendering
of content) that is obtained by multiplying 
<A HREF="kdu$sitor__set_scale.html#scale">scale</A> by 
<A HREF="kdu$sitor__set_scale.html#rendering_scale_adjustment">rendering_scale_adjustment</A>. This (potentially different) rendering scale, as
well as the full image dimensions and buffer surface
region, expressed relative to the rendering scale,
may be obtained by querying the 
<A HREF="kdu$r_buf.html">kdu_compositor_buf</A> member functions offered by the composition buffer
directly. The functions of interest here are:
</P><UL><LI>
<A HREF="kdu$r_buf__get$ing_scale.html">kdu_compositor_buf::get_rendering_scale</A>;
</LI><LI>
<A HREF="kdu$r_buf__get$ng_region.html">kdu_compositor_buf::get_rendering_region</A>; and
</LI><LI>
<A HREF="kdu$r_buf__get$tion_dims.html">kdu_compositor_buf::get_rendering_composition_dims</A>.
</LI></UL><P>
 After calling this function, and before calling 
<A HREF="kdu$sitor__process.html">process</A>, you must call 
<A HREF="kdu$sitor__set$r_surface.html">set_buffer_surface</A> to identify the portion of the image you want rendered,
expressed relative to 
<A HREF="kdu$sitor__set_scale.html#scale">scale</A> and the geometry represented by 
<A HREF="kdu$sitor__set_scale.html#transpose">transpose</A>, 
<A HREF="kdu$sitor__set_scale.html#hflip">hflip</A> and 
<A HREF="kdu$sitor__set_scale.html#vflip">vflip</A>. You must not assume that the image buffer returned
by a previous call to 
<A HREF="kdu$sitor__get$on_buffer.html">get_composition_buffer</A> is still valid, so you should generally call that
function again also to get a handle to the buffer which
will hold the composited imagery.
</P><P>
 Note that the current function does not actually verify
that the scale parameters are compatible with the composition
being constructed. It merely sets some internal state
information which will be used to adjust the internal
configuration on the next call to 
<A HREF="kdu$sitor__get$on_buffer.html">get_composition_buffer</A>, 
<A HREF="kdu$sitor__get$tion_dims.html">get_total_composition_dims</A> or 
<A HREF="kdu$sitor__process.html">process</A>. Any of these functions may return a NULL/false/empty
response if the scale parameters were found to be unachievable
during any step which they executed internally (this
could happen half way through processing a region,
if a tile-component with insufficient DWT levels is
encountered, for example).
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="ArgS">Arguments</A></H2><DIV CLASS="indented-text">
<H4><A NAME="transpose">transpose</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
</DIV>
<H4><A NAME="vflip">vflip</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
</DIV>
<H4><A NAME="hflip">hflip</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
</DIV>
<H4><A NAME="scale">scale</A> [<B>float</B>]</H4><DIV CLASS="indented-text">
<P>
A value larger than 1 implies that the image should
be composed at a larger (zoomed in) size than the nominal
size associated with 
<A HREF="kdu$sitor__add_ilayer.html">add_ilayer</A> and related functions. Conversely, a value smaller
than 1 implies a zoomed out representation.
</P><P>
 Note that the actual scale factors which must be applied
to individual codestream image components may be quite
different, since their composition rules may require
additional scaling factors.
</P><P>
 Note also that the optimal scale at which to render
an individual codestream is a positive integer or a
reciprocal power of 2. Since you may not know how the
global scale parameter supplied here translates into
the scale factor used for a particular codestream of
interest, this object provides a separate function,
<A HREF="kdu$sitor__fin$mal_scale.html">find_optimal_scale</A>, which may be used to guide the selection of optimal
scale factors, based on the codestream content which
is being used to render the information in a particular
region of interest. That function also allows you to
discover what limit was encountered if 
<A HREF="kdu$sitor__che$cale_code.html">check_invalid_scale_code</A> revealed a problem with the currently installed scaling
factor.
</P>
</DIV>
<H4><A NAME="rendering_scale_adjustment">rendering_scale_adjustment</A> [<B>float</B>]</H4><DIV CLASS="indented-text">
<P>
This default value of 1.0 for this argument ensures
that the composition buffer is rendered at the scale
supplied via 
<A HREF="kdu$sitor__set_scale.html#scale">scale</A>, which is what one would normally expect. It can be
useful, however, to supply a value less than 1.0 (typically
0.5 or 0.25), in which case the composition buffer
is dimensioned and rendered as if the 
<A HREF="kdu$sitor__set_scale.html#scale">scale</A> argument had been adjusted by this same factor, but
all dimensions and locations passed across the region-compositor's
API functions remain consistent with 
<A HREF="kdu$sitor__set_scale.html#scale">scale</A>, with the sole exception of the 
<B>new_rendered_region</B> argument returned by the 
<A HREF="kdu$sitor__process.html">process</A> function and the 
<B>invalidated_region</B> argument supplied to the 
<A HREF="kdu$sitor__inv$date_rect.html">invalidate_rect</A> function.
</P><P>
 For example, if 
<A HREF="kdu$sitor__set_scale.html#scale">scale</A>=1.0 and 
<A HREF="kdu$sitor__set_scale.html#rendering_scale_adjustment">rendering_scale_adjustment</A>=0.5, the total image dimensions returned by 
<A HREF="kdu$sitor__get$tion_dims.html">get_total_composition_dims</A> and the buffer surface region requested by 
<A HREF="kdu$sitor__set$r_surface.html">set_buffer_surface</A> (and returned via 
<A HREF="kdu$sitor__get$on_buffer.html">get_composition_buffer</A>) are all expressed at full scale (i.e., 
<A HREF="kdu$sitor__set_scale.html#scale">scale</A>=1.0), whereas the composition buffer is rendered at
half scale, having roughly half as many rows and columns
as one would expect based on the surface region supplied
to 
<A HREF="kdu$sitor__set$r_surface.html">set_buffer_surface</A> and returned via 
<A HREF="kdu$sitor__get$on_buffer.html">get_composition_buffer</A>. The actual rendered buffer surface dimensions and
the total composited image region to which it belongs
may be retrieved by calling member functions offered
by the 
<A HREF="kdu$r_buf.html">kdu_compositor_buf</A> object returned by 
<A HREF="kdu$sitor__get$on_buffer.html">get_composition_buffer</A>.
</P><P>
 The scale supplied via the 
<A HREF="kdu$sitor__set_scale.html#scale">scale</A> argument dictates all aspects of the behaviour of
the region-compositor other than actual rendering,
which is scaled according to the product of 
<A HREF="kdu$sitor__set_scale.html#scale">scale</A> and 
<A HREF="kdu$sitor__set_scale.html#rendering_scale_adjustment">rendering_scale_adjustment</A>. For example, the 
<A HREF="kdu$sitor__gen$e_metareq.html">generate_metareq</A> function generates JPIP metadata requests that are
relevant to a particular region of interest, expressed
relative only to 
<A HREF="kdu$sitor__set_scale.html#scale">scale</A>. As another example, 
<A HREF="kdu$sitor__find_point.html">find_point</A> locates the imagery layer that contains a particular
<B>point</B>, expressed relative only to 
<A HREF="kdu$sitor__set_scale.html#scale">scale</A>, even though it may assess visibility using content
rendered at a different resolution (if 
<A HREF="kdu$sitor__set_scale.html#rendering_scale_adjustment">rendering_scale_adjustment</A> is not 1.0). There are many other API functions that
work with locations and regions, all of which are expressed
relative only to 
<A HREF="kdu$sitor__set_scale.html#scale">scale</A>, the only two exceptions being the 
<A HREF="kdu$sitor__process.html">process</A> and 
<A HREF="kdu$sitor__inv$date_rect.html">invalidate_rect</A> functions which necessarily refer to the rendering
process itself.
</P><P>
 The 
<A HREF="kdu$sitor__set_scale.html#rendering_scale_adjustment">rendering_scale_adjustment</A> argument may take any positive value, but the product
of 
<A HREF="kdu$sitor__set_scale.html#scale">scale</A> and 
<A HREF="kdu$sitor__set_scale.html#rendering_scale_adjustment">rendering_scale_adjustment</A> must ultimately represent a scale at which content
can be rendered. If not, the 
<A HREF="kdu$sitor__che$cale_code.html">check_invalid_scale_code</A> function may report that the rendering scale is too
small or too large and 
<A HREF="kdu$sitor__fin$mal_scale.html">find_optimal_scale</A> can be used to determine the rendering scale (i.e.,
the product of 
<A HREF="kdu$sitor__set_scale.html#scale">scale</A> and 
<A HREF="kdu$sitor__set_scale.html#rendering_scale_adjustment">rendering_scale_adjustment</A>) that should be used to avoid invalid rendering conditions.
</P><P>
 The reason for providing a separate 
<A HREF="kdu$sitor__set_scale.html#rendering_scale_adjustment">rendering_scale_adjustment</A> parameter, that affects only the rendered composition
buffers, but none of the other dimensional information
passed across the region-compositor's API functions
(apart from 
<A HREF="kdu$sitor__process.html">process</A> and 
<A HREF="kdu$sitor__inv$date_rect.html">invalidate_rect</A>) is that this greatly simplifies the implementation
of interactive rendering applications that may prefer
to temporarily enter a "low-res" rendering state for
performance reasons (e.g., during a repetitive sequence
of user interactions that require frequent re-rendering).
</P>
</DIV>
</DIV>

<P ALIGN="CENTER"><HR></P><P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$sitor__wai$m_headers.html"> prev </A>||<A HREF="kdu$sitor__fin$mal_scale.html"> next </A>|</P>
</BODY>
</HTML>
