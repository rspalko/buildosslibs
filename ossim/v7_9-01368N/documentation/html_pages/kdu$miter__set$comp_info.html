<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (kdu_quality_limiter::set_comp_info) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
.function-text { padding-left: 80pt;
                 text-indent: -60pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#B4DCB4">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$miter__set$esolution.html"> prev </A>||<A HREF="kdu$miter__get$hted_rmse.html"> next </A>|</P>
<H1><A NAME="ToP">kdu_quality_limiter::set_comp_info</A></H1>
<DIR><DIR><H3><EM><U>Java:</U> Kdu_quality_limiter.Set_comp_info</EM></H3></DIR></DIR>
<P CLASS="function-text">virtual <B>void</B> set_comp_info(
<B>int</B>&nbsp;c,
<B>float</B>&nbsp;square_weight,
<B>kdu_int32</B>&nbsp;type_flags)</P>
<DIR><DIR><P CLASS="function-text"><EM><U>Java:</U> public native void Set_comp_info(
int&nbsp;c,
float&nbsp;square_weight,
int&nbsp;type_flags)</EM></P></DIR></DIR>
<P><A HREF="kdu$miter.html">Go to class description.</A></P>

<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
This function allows for the provision of individual
weights W_c for any output component 
<A HREF="kdu$miter__set$comp_info.html#c">c</A>, as well as an indication of what colour channel type
(if any) the component should be interpreted as holding.
The latter affects the algorithm for determining whether
or not a codestream component should be considered
to hold chroma-type information, which is used by 
<B>get_square_visual_weights</B> to generate suitable visual weighting factors. You
may call this function as often as desired, overwriting
previous values if desired. Any component c for which
there is no such call will default to having a weight
of 1.0 and no known colour type information.
</P><P>
 Note that the components 
<A HREF="kdu$miter__set$comp_info.html#c">c</A> are those that remain as "apparent" output components
after the application of any restrictions imposed by
the other arguments to 
<A HREF="kdu$tream__app$trictions__1.html">kdu_codestream::apply_input_restrictions</A> in the call which passes a 
<A HREF="kdu$miter.html">kdu_quality_limiter</A>.
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="ArgS">Arguments</A></H2><DIV CLASS="indented-text">
<H4><A NAME="c">c</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
</DIV>
<H4><A NAME="square_weight">square_weight</A> [<B>float</B>]</H4><DIV CLASS="indented-text">
<P>
Squared component weight (W_c)^2, as explained at length
in the comments that accompany the 
<A HREF="kdu$miter.html">kdu_quality_limiter</A> constructor, where a formula is also provided to help
you choose good component weights for the common case
in which some output components are sub-sampled, and
you intend to interpolate them as part of the rendering
process. NOTE: 
<A HREF="kdu$miter__set$comp_info.html#square_weight">square_weight</A> must be strictly positive!
</P><P>
 It is worth noting that the weights W_c refer to output
image components, each of which may be formed from
multiple codestream image components (via an inverse
decorrelating or multi-component transform). You do
not directly specify the properties of codestream image
components with this function.
</P>
</DIV>
<H4><A NAME="type_flags">type_flags</A> [<B>kdu_int32</B>]</H4><DIV CLASS="indented-text">
<P>
This argument is used to supply any information that
might be available concerning the colorimetric interpretation
of a component. If the word is 0, nothing is known;
this is OK, but may well prevent the discovery of chroma-type
codestream components by working back through a multi-component
transform; the discovery of chroma-type components
can lead to the legitimate usage of more aggressive
visual weigths, leading to more aggressive truncation
and hence lower complexity rendering without significant
quality impairment. For this reason, if colour space
information is available to the application, it is
worth using it to configure the 
<A HREF="kdu$miter__set$comp_info.html#type_flags">type_flags</A> in a meaningful way.
</P><P>
 Only the sign bit of the 
<A HREF="kdu$miter__set$comp_info.html#type_flags">type_flags</A> word has absolute meaning. If set, the component is
considered to hold some kind of chroma information
&mdash; this may be the case where the codestream output
components represent YCbCr content directly, as opposed
to RGB content that may have been compressed using
a decorrelating colour transform. For the moment at
least, if the sign bit is set, any other flags are
automatically discarded from 
<A HREF="kdu$miter__set$comp_info.html#type_flags">type_flags</A> to facilitate internal reasoning by the algorithm
used to deduce chromaticity of codestream components.
</P><P>
 The other bits in the 
<A HREF="kdu$miter__set$comp_info.html#type_flags">type_flags</A> word should be considered to correspond to distinct
colour channels in some kind of colour space. For example,
in an RGB colour space, you would set bit 0 if the
component represents red, bit 1 if it represents green,
and bit 2 if it represents blue. In a CMYK colour space,
you would set bit 0 for cyan, bit 1 for magenta, and
so forth. The order of the components is not really
important, but the algorithm used to determine whether
a multi-component transform has chroma-type input components
relies upon discovering transforms that operate on
components with at least three different colour types,
found within the three least significant type flag
bits.
</P><P>
 You should not set more than one bit in the 
<A HREF="kdu$miter__set$comp_info.html#type_flags">type_flags</A> word, but you should leave the word zero if you do
not intend to interpret the component as colour.
</P>
</DIV>
</DIV>

<P ALIGN="CENTER"><HR></P><P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$miter__set$esolution.html"> prev </A>||<A HREF="kdu$miter__get$hted_rmse.html"> next </A>|</P>
</BODY>
</HTML>
