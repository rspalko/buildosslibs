<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (kdu_stripe_decompressor::start) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
.function-text { padding-left: 80pt;
                 text-indent: -60pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#B4DCB4">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$2essor__~kd$mpressor.html"> prev </A>||<A HREF="kdu$2essor__finish.html"> next </A>|</P>
<H1><A NAME="ToP">kdu_stripe_decompressor::start</A></H1>
<DIR><DIR><H3><EM><U>Java:</U> Kdu_stripe_decompressor.Start</EM></H3></DIR></DIR>
<P CLASS="function-text"><B>void</B> start(
<A HREF ="kdu$tream.html">kdu_codestream</A>&nbsp;codestream,
<B>bool</B>&nbsp;force_precise=false,
<B>bool</B>&nbsp;want_fastest=false,
<A HREF ="kdu$d_env.html">kdu_thread_env</A>&nbsp;*&nbsp;env=NULL,
<A HREF ="kdu$2queue.html">kdu_thread_queue</A>&nbsp;*&nbsp;env_queue=NULL,
<B>int</B>&nbsp;env_dbuf_height=-1,
<B>int</B>&nbsp;env_tile_concurrency=-1,
const&nbsp;<A HREF ="kdu$1arams.html">kdu_push_pull_params</A>&nbsp;*&nbsp;multi_xform_extra_params=NULL)</P>
<DIR><DIR><P CLASS="function-text"><EM><U>Java:</U> public native void Start(
Kdu_codestream&nbsp;codestream,
boolean&nbsp;force_precise,
boolean&nbsp;want_fastest,
Kdu_thread_env&nbsp;env,
Kdu_thread_queue&nbsp;env_queue,
int&nbsp;env_dbuf_height,
int&nbsp;env_tile_concurrency)</EM></P></DIR></DIR>
<P><A HREF="kdu$2essor.html">Go to class description.</A></P>

<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
Call this function to initialize the object for decompression.
Each call to 
<A HREF="kdu$2essor__start.html">start</A> must be matched by a call to 
<A HREF="kdu$2essor__finish.html">finish</A>, but you may re-use the object to process subsequent
images, if you like. If you are using the object in
a multi-threaded processing environment, be sure to
read the notes accompanying 
<A HREF="kdu$2essor__reset.html">reset</A> and 
<A HREF="kdu$2essor__finish.html">finish</A> to understand which you should use. When reading these
notes, bear in mind also that from Kakadu version 7.5
on, the current object's destructor invokes 
<A HREF="kdu$2essor__reset.html">reset</A>, rather than 
<A HREF="kdu$2essor__finish.html">finish</A>, since the latter was not safe for a destructor.
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="ArgS">Arguments</A></H2><DIV CLASS="indented-text">
<H4><A NAME="codestream">codestream</A> [<A HREF ="kdu$tream.html">kdu_codestream</A>]</H4><DIV CLASS="indented-text">
<P>
Interface to a 
<A HREF="kdu$tream.html">kdu_codestream</A> object whose 
<B>create</B> function has already been called. Before passing the
code-stream to this function, you might like to alter
the geometry by calling 
<A HREF="kdu$tream__cha$ppearance.html">kdu_codestream::change_appearance</A>, or you might like to restrict the spatial region,
image components or number of layers which will appear
to be present during decompression, by calling one
of the 
<A HREF="kdu$tream__app$trictions__1.html">kdu_codestream::apply_input_restrictions</A> functions.
</P>
</DIV>
<H4><A NAME="force_precise">force_precise</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
<P>
If true, 32-bit internal representations are used by
the decompression engines created by this object, regardless
of the precision of the image samples reported by 
<A HREF="kdu$tream__get$bit_depth.html">kdu_codestream::get_bit_depth</A>.
</P>
</DIV>
<H4><A NAME="want_fastest">want_fastest</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
<P>
If this argument is true and 
<A HREF="kdu$2essor__start.html#force_precise">force_precise</A> is false, the function selects a 16-bit internal representation
(usually leads to the fastest processing) even if this
will result in reduced image quality, at least for
irreversible processing. For image components which
require reversible compression, the 32-bit representation
must be selected if the image sample precision is too
high, or else numerical overflow might occur.
</P>
</DIV>
<H4><A NAME="env">env</A> [<A HREF ="kdu$d_env.html">kdu_thread_env</A>&nbsp;*]</H4><DIV CLASS="indented-text">
<P>
This argument is used to establish multi-threaded processing.
For a discussion of the multi-threaded processing features
offered by the present object, see the introductory
comments to 
<A HREF="kdu$2essor.html">kdu_stripe_decompressor</A>. We remind you here, however, that all calls to 
<A HREF="kdu$2essor__start.html">start</A>, 
<A HREF="kdu$2essor__pull_stripe__1.html">pull_stripe</A> and 
<A HREF="kdu$2essor__finish.html">finish</A> must be executed from the same thread, which is identified
only in this function.
</P><P>
 If you re-use the object to process a subsequent image,
you may change threads between the two uses, passing
the appropriate 
<A HREF="kdu$d_env.html">kdu_thread_env</A> reference in each call to 
<A HREF="kdu$2essor__start.html">start</A>.
</P><P>
 If the 
<A HREF="kdu$2essor__start.html#env">env</A> argument is NULL, all processing is single threaded.
Different threads can potentially invoke the 
<A HREF="kdu$2essor__start.html">start</A>, 
<A HREF="kdu$2essor__pull_stripe__1.html">pull_stripe</A> and 
<A HREF="kdu$2essor__finish.html">finish</A> functions but they must be serialized by the application
so that it is not possible to have any more than one
thread working on any of the compression tasks at once.
</P>
</DIV>
<H4><A NAME="env_queue">env_queue</A> [<A HREF ="kdu$2queue.html">kdu_thread_queue</A>&nbsp;*]</H4><DIV CLASS="indented-text">
<P>
This argument is ignored unless 
<A HREF="kdu$2essor__start.html#env">env</A> is non-NULL, in which case a non-NULL 
<A HREF="kdu$2essor__start.html#env_queue">env_queue</A> means that all multi-threaded processing queues created
inside the present object, by calls to 
<A HREF="kdu$2essor__pull_stripe__1.html">pull_stripe</A>, should be created as sub-queues of the identified
<A HREF="kdu$2essor__start.html#env_queue">env_queue</A>.
</P><P>
 One application for a non-NULL 
<A HREF="kdu$2essor__start.html#env_queue">env_queue</A> might be one which processes two frames of a video
sequence in parallel. There can be some benefit to
doing this, since it can avoid the small amount of
thread idle time which often appears at the end of
the last call to the 
<A HREF="kdu$2essor__pull_stripe__1.html">pull_stripe</A> function prior to 
<A HREF="kdu$2essor__finish.html">finish</A>. In this case, each concurrent frame would have its
own 
<A HREF="kdu$2essor__start.html#env_queue">env_queue</A>, and its own 
<A HREF="kdu$2essor.html">kdu_stripe_decompressor</A> object. Moreover, the 
<A HREF="kdu$2essor__start.html#env_queue">env_queue</A> associated with a given 
<A HREF="kdu$2essor.html">kdu_stripe_decompressor</A> object can be used to run a job which invokes the
<A HREF="kdu$2essor__start.html">start</A>, 
<A HREF="kdu$2essor__pull_stripe__1.html">pull_stripe</A> and 
<A HREF="kdu$2essor__finish.html">finish</A> member functions. In this case, however, it is particularly
important that the 
<A HREF="kdu$2essor__start.html">start</A>, 
<A HREF="kdu$2essor__pull_stripe__1.html">pull_stripe</A> and 
<A HREF="kdu$2essor__finish.html">finish</A> functions all be called from within the execution
of a single job, since otherwise there is no guarantee
that they would all be executed from the same thread,
whose importance has already been stated above.
</P><P>
 Note that 
<A HREF="kdu$2essor__start.html#env_queue">env_queue</A> is not detached from the multi-threaded environment
(identified by 
<A HREF="kdu$2essor__start.html#env">env</A>) when the current object is destroyed, or by 
<A HREF="kdu$2essor__finish.html">finish</A>. It is, therefore, possible to have other 
<A HREF="kdu$2essor.html">kdu_stripe_decompressor</A> objects (or indeed any other processing machinery)
share this 
<A HREF="kdu$2essor__start.html#env_queue">env_queue</A>.
</P>
</DIV>
<H4><A NAME="env_dbuf_height">env_dbuf_height</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
<P>
This argument may be used to introduce and control
parallelism in the DWT processing steps, allowing you
to distribute the load associated with multiple tile-components
across multiple threads. In the simplest case, this
argument is 0, and parallel processing applies only
to the block decoding processes. For a small number
of processors, this is usually sufficient to keep all
CPU's active. If this argument is non-zero, however,
the 
<A HREF="kdu$hesis.html">kdu_multi_synthesis</A> objects on which all processing is based, are created
with 
<B>double_buffering</B> equal to true and a 
<B>processing_stripe_height</B> equal to the value supplied for this argument. See
<A HREF="kdu$hesis__create__1.html">kdu_multi_synthesis::create</A> for a more comprehensive discussion of double buffering
principles and guidelines.
</P><P>
 Note that the special value -1 is particularly useful,
as it causes 
<A HREF="kdu$hesis__create__1.html">kdu_multi_synthesis::create</A> to select a good double buffering stripe height automatically.
In the case where the codestream contains multiple
horizontally adjacent tiles and the stripes retrieved
via the 
<A HREF="kdu$2essor__pull_stripe__1.html">pull_stripe</A> function correspond to whole tile rows (preferable
and likely to occur if you use the 
<A HREF="kdu$2essor__get$_heights.html">get_recommended_stripe_heights</A> function to determine good stripe heights) the best
policy is usually to use an 
<A HREF="kdu$2essor__start.html#env_dbuf_height">env_dbuf_height</A> value that is at least half the tile height. Otherwise,
the best value is usually closer to 30 or 40. Given
these complexities, it is usually best to pass -1 for
this argument (the default), so that the internal machinery
is free to make these sort of decisions itself.
</P>
</DIV>
<H4><A NAME="env_tile_concurrency">env_tile_concurrency</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
<P>
This argument is of interest when decompressing from
codestreams with many small tiles, in a multi-threaded
(
<A HREF="kdu$2essor__start.html#env">env</A> != NULL) processing environment. It is especially
interesting whre the stripe height used for processing
is equal to (or a multiple of) the tile height, so
that each call to 
<A HREF="kdu$2essor__pull_stripe__1.html">pull_stripe</A> results in the opening and closing of tiles one by
one. The internal machinery prefers to open tiles and
start their tile processing engines in advance, keeping
a list of up to 
<A HREF="kdu$2essor__start.html#env_tile_concurrency">env_tile_concurrency</A>-1 future tile processing engines that have already
been started, while data is being pulled out of a current
tile processing engine. These future tile processing
engines can contribute processing jobs to the multi-threaded
processing machinery, but those jobs have progressively
lower priority the further they are from the current
tile of interest. This ensures that the extra jobs
are used only to keep threads from going idle, not
to delay processing of the current active tile. Larger
values of 
<A HREF="kdu$2essor__start.html#env_tile_concurrency">env_tile_concurrency</A> reduce the risk that any thread needs to go idle,
increasing overall processing throughput, at the expense
of larger memory concumption. If the value is overly
large, there may also be some negative impact on the
efficiency with which jobs are dequeued by the underlying
multi-threaded processing machinery.
</P><P>
 If the value passed for this argument is less than
or equal to 0, the internal machinery automatically
selects a reasonable tile concurrency level. The algorithm
used to do this may be very simple, but may also evolve
over time, so it is always worth testing the performance
of your application with a variety of different values
for this arguement.
</P><P>
 Whatever value is passed for this argument, the actual
value used internally is limited to at most 1 more
than the number of tiles spanned by the image width,
so that the maximum number of future tile processing
engines that will be started is at most equal to the
number of tiles across the image.
</P><P>
 If the stripes retrieved via 
<B>pull_stripes</B> are not high enough to span an entire row of tiles,
the impact of this argument is slightly different.
In this case, the internal machinery always needs to
keep an entire row of open tiles with active tile processing
engines. If the 
<A HREF="kdu$2essor__start.html#env_tile_concurrency">env_tile_concurrency</A> argument is not equal to 1, the function also starts
tile processing engines for the next row of tiles &mdash;
i.e., one whose future row of tile processing engines.
Otherwise, the current row of tile processing engines
is started only just in time &mdash; no concurrency
across rows of tiles.
</P><P>
 For maximum multi-threaded processing efficiency when
working with small tiles, you should pull stripes whose
height is exactly one tile height, setting 
<A HREF="kdu$2essor__start.html#env_dbuf_height">env_dbuf_height</A> equal to half the stripe height (or a little more)
and setting 
<A HREF="kdu$2essor__start.html#env_tile_concurrency">env_tile_concurrency</A> to a modest number (e.g., 4). The 
<A HREF="kdu$2essor__start.html#env_dbuf_height">env_dbuf_height</A> strategy is implemented automatically if you pass
-1 for that argument, which is usually best and simplest.
The 
<B>env_tile_concurrentcy</B> strategy is also likely to be implemented automatically
if you pass 0 or a a negative value for this argument.
The reason for selecting such a large DWT double buffering
size for images with lots of small tiles is that it
allows each tile processing engine to buffer all samples
in its tile so that future tile processing engines
can run to completion, if required, while data is being
pulled from a current tile. This allows all 
<A HREF="kdu$2essor__start.html#env_tile_concurrency">env_tile_concurrency</A> concurrently active tile processing engines to contribute
the maximum possible number of processing jobs to the
multi-threaded job pool. The internal machinery ensures
that the tile processing engines are prioritised by
assigning increasing sequence indices to each engine's
<A HREF="kdu$2queue.html">kdu_thread_queue</A>, so that tiles almost certainly complete in order,
minimising the risk that the thread which calls 
<A HREF="kdu$2essor__pull_stripe__1.html">pull_stripe</A> is unnecessarily suspended, since that might eventually
starve other parts of the system of sufficient work.
</P>
</DIV>
<H4><A NAME="multi_xform_extra_params">multi_xform_extra_params</A> [const&nbsp;<A HREF ="kdu$1arams.html">kdu_push_pull_params</A>&nbsp;*]</H4><DIV CLASS="indented-text">
<P>
This optional argument is passed along internally to
the 
<A HREF="kdu$hesis__create__1.html">kdu_multi_synthesis::create</A> function when it is called to set up each tile processing
engine, which may give you extra control over the internal
operation of the compression machinery.
</P>
</DIV>
</DIV>

<P ALIGN="CENTER"><HR></P><P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$2essor__~kd$mpressor.html"> prev </A>||<A HREF="kdu$2essor__finish.html"> next </A>|</P>
</BODY>
</HTML>
