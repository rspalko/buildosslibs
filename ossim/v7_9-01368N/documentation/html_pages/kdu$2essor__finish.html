<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (kdu_stripe_decompressor::finish) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
.function-text { padding-left: 80pt;
                 text-indent: -60pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#B4DCB4">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ReturnS"> return value </A>||<A HREF="kdu$2essor__start.html"> prev </A>||<A HREF="kdu$2essor__reset.html"> next </A>|</P>
<H1><A NAME="ToP">kdu_stripe_decompressor::finish</A></H1>
<DIR><DIR><H3><EM><U>Java:</U> Kdu_stripe_decompressor.Finish</EM></H3></DIR></DIR>
<P CLASS="function-text"><B>bool</B> finish(
)</P>
<DIR><DIR><P CLASS="function-text"><EM><U>Java:</U> public native boolean Finish(
)</EM></P></DIR></DIR>
<P><A HREF="kdu$2essor.html">Go to class description.</A></P>

<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
Each call to 
<A HREF="kdu$2essor__start.html">start</A> must be bracketed by a call to either 
<A HREF="kdu$2essor__finish.html">finish</A> or 
<A HREF="kdu$2essor__reset.html">reset</A>, unless you intend to use the object only once, in
which case the destructor implicitly calls 
<A HREF="kdu$2essor__reset.html">reset</A>. It is important that you know the difference between
<A HREF="kdu$2essor__finish.html">finish</A> and 
<A HREF="kdu$2essor__reset.html">reset</A>, especially in multi-threaded applications. The 
<A HREF="kdu$2essor__finish.html">finish</A> function does the following things:
</P><UL><LI>
Waits for any multi-threaded processing initiated by
the object to complete, requesting premature completion
first.
</LI><LI>
Invokes 
<A HREF="kdu$d_env__cs_terminate.html">kdu_thread_env::cs_terminate</A> on any non-NULL 
<B>env</B> object that was passed to 
<A HREF="kdu$2essor__start.html">start</A>.
</LI><LI>
Destroys all 
<A HREF="kdu$hesis.html">kdu_multi_synthesis</A> tile-processing engines.
</LI><LI>
Closes any open tile interfaces on the 
<B>codestream</B> that was passed to 
<A HREF="kdu$2essor__start.html">start</A>, being careful to also close any tiles that may have
been the subject of a background tile opening request
(multi-threaded processing case only).
</LI></UL><P>
 This means that any non-NULL 
<B>env</B> argument that was passed to 
<A HREF="kdu$2essor__start.html">start</A> must still refer to a valid 
<A HREF="kdu$d_env.html">kdu_thread_env</A> object that has not been destroyed, by the time this
function is called.
</P><P>
 Note also that this function does not actually deallocate
the primary memory surfaces that were allocated for
internal tile processing. These are deliberately retained
internally so that they can be re-used if the 
<A HREF="kdu$2essor__start.html">start</A> function is called again. If you wish to deallocate
these immediately, you can either invoke 
<A HREF="kdu$2essor__reset.html">reset</A> or the object's destructor.
</P><P>
 You can always call 
<A HREF="kdu$2essor__finish.html">finish</A> or 
<A HREF="kdu$2essor__reset.html">reset</A> again after this function returns, without doing any
harm. In fact, a subsequent call to 
<A HREF="kdu$2essor__reset.html">reset</A> is exactly what you need to free all allocated memory,
noting that this also happens in the destructor.
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="ReturnS">Return Value</A></H2><DIV CLASS="indented-text">
<P>
True only if all available image data was recovered
using the 
<A HREF="kdu$2essor__pull_stripe__1.html">pull_stripe</A> function. Regardless of the return value, however,
all processing (including background multi-threaded
processing) is terminated by this call.
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ReturnS"> return value </A>||<A HREF="kdu$2essor__start.html"> prev </A>||<A HREF="kdu$2essor__reset.html"> next </A>|</P>
</BODY>
</HTML>
