<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (kdu_stripe_compressor::start) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
.function-text { padding-left: 80pt;
                 text-indent: -60pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#B4DCB4">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$1essor__~kd$mpressor.html"> prev </A>||<A HREF="kdu$1essor__get$sequence.html"> next </A>|</P>
<H1><A NAME="ToP">kdu_stripe_compressor::start</A></H1>
<DIR><DIR><H3><EM><U>Java:</U> Kdu_stripe_compressor.Start</EM></H3></DIR></DIR>
<P CLASS="function-text"><B>void</B> start(
<A HREF ="kdu$tream.html">kdu_codestream</A>&nbsp;codestream,
<B>int</B>&nbsp;num_layer_specs=0,
const&nbsp;<B>kdu_long</B>&nbsp;*&nbsp;layer_sizes=NULL,
const&nbsp;<B>kdu_uint16</B>&nbsp;*&nbsp;layer_slopes=NULL,
<B>kdu_uint16</B>&nbsp;min_slope_threshold=0,
<B>bool</B>&nbsp;no_prediction=false,
<B>bool</B>&nbsp;force_precise=false,
<B>bool</B>&nbsp;record_layer_info_in_comment=true,
<B>double</B>&nbsp;size_tolerance=0.0,
<B>int</B>&nbsp;num_components=0,
<B>bool</B>&nbsp;want_fastest=false,
<A HREF ="kdu$d_env.html">kdu_thread_env</A>&nbsp;*&nbsp;env=NULL,
<A HREF ="kdu$2queue.html">kdu_thread_queue</A>&nbsp;*&nbsp;env_queue=NULL,
<B>int</B>&nbsp;env_dbuf_height=-1,
<B>int</B>&nbsp;env_tile_concurrency=-1,
<B>bool</B>&nbsp;trim_to_rate=true,
<B>int</B>&nbsp;flush_flags=0,
const&nbsp;<A HREF ="kdu$1arams.html">kdu_push_pull_params</A>&nbsp;*&nbsp;multi_xform_extra_params=NULL)</P>
<DIR><DIR><P CLASS="function-text"><EM><U>Java:</U> public native void Start(
Kdu_codestream&nbsp;codestream,
int&nbsp;num_layer_specs,
long[]&nbsp;layer_sizes,
int[]&nbsp;layer_slopes,
int&nbsp;min_slope_threshold,
boolean&nbsp;no_prediction,
boolean&nbsp;force_precise,
boolean&nbsp;record_layer_info_in_comment,
double&nbsp;size_tolerance,
int&nbsp;num_components,
boolean&nbsp;want_fastest,
Kdu_thread_env&nbsp;env,
Kdu_thread_queue&nbsp;env_queue,
int&nbsp;env_dbuf_height,
int&nbsp;env_tile_concurrency,
boolean&nbsp;trim_to_rate,
int&nbsp;flush_flags)</EM></P></DIR></DIR>
<P><A HREF="kdu$1essor.html">Go to class description.</A></P>

<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
Call this function to initialize the object for compression.
Each call to 
<A HREF="kdu$1essor__start.html">start</A> must be matched by a call to either 
<A HREF="kdu$1essor__finish.html">finish</A> or 
<A HREF="kdu$1essor__reset.html">reset</A>, after which you may re-use the object to compress
subsequent images, if you like. If you are using the
object in a multi-threaded processing environment,
be sure to read the notes accompanying 
<A HREF="kdu$1essor__reset.html">reset</A> and 
<A HREF="kdu$1essor__finish.html">finish</A> to understand which you should use. When reading these
notes, bear in mind also that from Kakadu version 7.5
on, the current object's destructor invokes 
<A HREF="kdu$1essor__reset.html">reset</A>, rather than 
<A HREF="kdu$1essor__finish.html">finish</A>, since the latter was not safe for a destructor.
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="ArgS">Arguments</A></H2><DIV CLASS="indented-text">
<H4><A NAME="codestream">codestream</A> [<A HREF ="kdu$tream.html">kdu_codestream</A>]</H4><DIV CLASS="indented-text">
<P>
Interface to a 
<A HREF="kdu$tream.html">kdu_codestream</A> object whose 
<B>create</B> function has already been called. The 
<A HREF="kdu_params__fin$lize_all__1.html">kdu_params::finalize_all</A> function should not be called by the application;
it will be invoked from within the present function,
possibly after making some final adjustments to coding
parameter attributes which have not been configured
by the application.
</P>
</DIV>
<H4><A NAME="num_layer_specs">num_layer_specs</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
<P>
If this argument is equal to 0, the number of quality
layers to build into the code-stream is recovered from
the 
<A HREF="globals.html#Clayers">Clayers</A> coding parameter attribute, which the application
may have been configured prior to calling this function.
If the 
<A HREF="globals.html#Clayers">Clayers</A> attribute was not set, it will default to 1 when the
<A HREF="kdu_params__fin$lize_all__1.html">kdu_params::finalize_all</A> function is called from within this function. If the
present argument is greater than 0, and the 
<A HREF="globals.html#Clayers">Clayers</A> attribute has not already been set, it will be set
equal to the value of 
<A HREF="kdu$1essor__start.html#num_layer_specs">num_layer_specs</A>. Regardless of the final number of code-stream quality
layers which are used, the 
<A HREF="kdu$1essor__start.html#num_layer_specs">num_layer_specs</A> argument provides the number of entries in the 
<A HREF="kdu$1essor__start.html#layer_sizes">layer_sizes</A> and 
<A HREF="kdu$1essor__start.html#layer_slopes">layer_slopes</A> arrays, if non-NULL. These arrays, if provided, allow
the application to specify the properties of the quality
layers. If no layer sizes or slopes are specified,
a logarithmically spaced set of quality layers will
be constructed, following the conventions described
with the 
<A HREF="kdu$tream__flush.html">kdu_codestream::flush</A> function.
</P>
</DIV>
<H4><A NAME="layer_sizes">layer_sizes</A> [const&nbsp;<B>kdu_long</B>&nbsp;*]</H4><DIV CLASS="indented-text">
<P>
If non-NULL, this argument points to an array with
<A HREF="kdu$1essor__start.html#num_layer_specs">num_layer_specs</A> entries, containing the cumulative number of bytes
from the start of the code-stream to the end of each
quality layer, if the code-stream were to be arranged
in layer progressive order. The code-stream may be
arranged in a very different order, of course, but
that has no impact on the sizes of the layers, as controlled
by this argument. If the actual number of quality layers,
as specified by the 
<A HREF="globals.html#Clayers">Clayers</A> attribute, is smaller than 
<A HREF="kdu$1essor__start.html#num_layer_specs">num_layer_specs</A>, not all of the entries in this array will be used.
If the actual number of quality layers is larger than
<A HREF="kdu$1essor__start.html#num_layer_specs">num_layer_specs</A>, the additional quality layers will be empty. This
argument is ignored if 
<A HREF="kdu$1essor__start.html#num_layer_specs">num_layer_specs</A> is 0.
</P><P>
 Note that the interpretation of this argument is modified
substantially if all of the following conditions hold:
</P><UL><LI>
the 
<A HREF="kdu$1essor__start.html#flush_flags">flush_flags</A> argument includes the 
<A HREF="globals.html#KDU_FLUSH_USES_THRESHOLDS_AND_SIZES">KDU_FLUSH_USES_THRESHOLDS_AND_SIZES</A> flag;
</LI><LI>
the 
<B>flush_flag</B> argument does not include the 
<A HREF="globals.html#KDU_FLUSH_THRESHOLDS_ARE_HINTS">KDU_FLUSH_THRESHOLDS_ARE_HINTS</A> flag; and
</LI><LI>
the 
<A HREF="kdu$1essor__start.html#layer_slopes">layer_slopes</A> argument is non-NULL with a first entry that is non-zero.
</LI></UL><P>
 When all of the above conditions hold, the quality
layers are driven primarily by the distortion-length
slope thresholds provided via 
<A HREF="kdu$1essor__start.html#layer_slopes">layer_slopes</A>, while the 
<A HREF="kdu$1essor__start.html#layer_sizes">layer_sizes</A> values are interpreted as lower bounds on the size
of the quality layers that come into effect only if
the number of bytes produced by using the 
<A HREF="kdu$1essor__start.html#layer_slopes">layer_slopes</A> values is too small. This is explained more carefully
in the comments accompanying 
<A HREF="kdu$tream__flush.html">kdu_codestream::flush</A>.
</P>
</DIV>
<H4><A NAME="layer_slopes">layer_slopes</A> [const&nbsp;<B>kdu_uint16</B>&nbsp;*]</H4><DIV CLASS="indented-text">
<P>
If non-NULL, this argument points to an array with
<A HREF="kdu$1essor__start.html#num_layer_specs">num_layer_specs</A> entries, containing distortion-length slope thresholds
to use when generating each quality layer. This argument
is ignored if 
<A HREF="kdu$1essor__start.html#num_layer_specs">num_layer_specs</A> is 0.
</P><P>
 The argument is also ignored if 
<A HREF="kdu$1essor__start.html#layer_sizes">layer_sizes</A> is non-NULL, except in the event that 
<A HREF="kdu$1essor__start.html#flush_flags">flush_flags</A> includes the 
<A HREF="globals.html#KDU_FLUSH_THRESHOLDS_ARE_HINTS">KDU_FLUSH_THRESHOLDS_ARE_HINTS</A> flag or the 
<A HREF="globals.html#KDU_FLUSH_USES_THRESHOLDS_AND_SIZES">KDU_FLUSH_USES_THRESHOLDS_AND_SIZES</A>. In the former case, quality layer generation is driven
by the target sizes supplied via the 
<A HREF="kdu$1essor__start.html#layer_sizes">layer_sizes</A> array, but the 
<A HREF="kdu$1essor__start.html#layer_slopes">layer_slopes</A> values are treated as a good starting point for the
rate control algorithm, which may reduce computational
effort in converging to a suitable operating point.
The 
<A HREF="globals.html#KDU_FLUSH_USES_THRESHOLDS_AND_SIZES">KDU_FLUSH_USES_THRESHOLDS_AND_SIZES</A> flag has a very special interpretation if the 
<A HREF="globals.html#KDU_FLUSH_THRESHOLDS_ARE_HINTS">KDU_FLUSH_THRESHOLDS_ARE_HINTS</A> flag is missing and 
<A HREF="kdu$1essor__start.html#layer_slopes">layer_slopes</A>[0] is non-zero. In this case, the quality layer generation
process is driven by the distortion-length slope thresholds
provided here, and any additional information supplied
via 
<A HREF="kdu$1essor__start.html#layer_sizes">layer_sizes</A> is used only to lower bound the generated quality
layer sizes in the event that the slope thresholds
produce unexpectedly small quality layers.
</P><P>
 For a detailed explanation of the logarithmic representation
used for distortion length slope thresholds in Kakadu,
see the API documentation that accompanies the 
<A HREF="kdu$tream__flush.html">kdu_codestream::flush</A> function.
</P>
</DIV>
<H4><A NAME="min_slope_threshold">min_slope_threshold</A> [<B>kdu_uint16</B>]</H4><DIV CLASS="indented-text">
<P>
If this argument is non-zero, the 
<A HREF="kdu$tream__set$1threshold.html">kdu_codestream::set_min_slope_threshold</A> function will be used to apply this slope threshold
prior to compression. As explained in connection with
that function, this can help to speed up the compression
process significantly. Although the application could
invoke 
<A HREF="kdu$tream__set$1threshold.html">kdu_codestream::set_min_slope_threshold</A> itself, providing a non-zero argument here will prevent
the present function from calling 
<A HREF="kdu$tream__set$max_bytes.html">kdu_codestream::set_max_bytes</A> if the 
<A HREF="kdu$1essor__start.html#layer_sizes">layer_sizes</A> array is non-NULL. More precisely, the function follows
the following set of rules in determining what speedup
features to apply:
</P><UL><LI>
If 
<A HREF="kdu$1essor__start.html#no_prediction">no_prediction</A> is true, no speedup features are applied;
</LI><LI>
else, if 
<A HREF="kdu$1essor__start.html#min_slope_threshold">min_slope_threshold</A> is non-zero, the value will be supplied to 
<A HREF="kdu$tream__set$1threshold.html">kdu_codestream::set_min_slope_threshold</A>;
</LI><LI>
else, if 
<A HREF="kdu$1essor__start.html#layer_sizes">layer_sizes</A> is non-NULL, the last entry in the 
<A HREF="kdu$1essor__start.html#layer_sizes">layer_sizes</A> array will be passed to 
<A HREF="kdu$tream__set$max_bytes.html">kdu_codestream::set_max_bytes</A>;
</LI><LI>
else, if 
<A HREF="kdu$1essor__start.html#layer_slopes">layer_slopes</A> is non-NULL, the last entry in the 
<A HREF="kdu$1essor__start.html#layer_slopes">layer_slopes</A> array will be passed to 
<A HREF="kdu$tream__set$1threshold.html">kdu_codestream::set_min_slope_threshold</A>.
</LI></UL>
</DIV>
<H4><A NAME="no_prediction">no_prediction</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
<P>
If true, neither the 
<A HREF="kdu$tream__set$max_bytes.html">kdu_codestream::set_max_bytes</A> function, nor the 
<A HREF="kdu$tream__set$1threshold.html">kdu_codestream::set_min_slope_threshold</A> function will be invoked. Applications should set
this argument to true only if they want to adopt a
very conservative stance in relation to maximizing
image quality at the expense of compression speed.
For typical images, Kakadu's code-block truncation
prediction mechanisms have no impact on image quality
at all, while saving processing time.
</P>
</DIV>
<H4><A NAME="force_precise">force_precise</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
<P>
If true, 32-bit internal representations are used by
the compression engines created by this object, regardless
of the precision of the image samples reported by 
<A HREF="kdu$tream__get$bit_depth.html">kdu_codestream::get_bit_depth</A>.
</P>
</DIV>
<H4><A NAME="record_layer_info_in_comment">record_layer_info_in_comment</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
<P>
If true, the rate-distortion slope and the target number
of bytes associated with each quality layer will be
recorded in a COM (comment) marker segment in the main
code-stream header. This can be very useful for applications
which wish to process the code-stream later in a manner
which depends upon the interpretation of the quality
layers. For this reason, you should generally set this
argument to true, unless you want to get the smallest
possible file size when compressing small images. For
more information on this option, consult the comments
appearing with its namesake in 
<A HREF="kdu$tream__flush.html">kdu_codestream::flush</A>.
</P>
</DIV>
<H4><A NAME="size_tolerance">size_tolerance</A> [<B>double</B>]</H4><DIV CLASS="indented-text">
<P>
This argument is ignored unless layering is controlled
by cumulative layer sizes supplied via a 
<A HREF="kdu$1essor__start.html#layer_sizes">layer_sizes</A> array. In this case, it may be used to trade accuracy
for speed when determining the distortion-length slopes
which achieve the target layer sizes as closely as
possible. In particular, the algorithm will finish
once it has found a distortion-length slope which yields
a size in the range target*(1-tolerance) &lt;= size
&lt;= target, where target is the target size for the
relevant layer. If no such slope can be found, the
layer is assigned a slope such that the size is as
close as possible to the target, without exceeding
it.
</P>
</DIV>
<H4><A NAME="num_components">num_components</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
<P>
If zero, the number of image components to be supplied
to the 
<A HREF="kdu$1essor__push_stripe__1.html">push_stripe</A> function is identical to the value returned by 
<A HREF="kdu$tream__get$omponents.html">kdu_codestream::get_num_components</A>, with its optional 
<B>want_output_comps</B> argument set to true. However, you may supply a smaller
number of image components during compression, if you
think that these provide sufficient information to
generate all codestream image components. This can
happen where a Part 2 multi-component transformation
defines more MCT output components than there are codestream
image components. Then, during compression, it may
be possible to invert the defined multi-component transform
network by supplying only a subset of the MCT output
components as source components (the components supplied
to 
<A HREF="kdu$1essor__push_stripe__1.html">push_stripe</A>). If a non-zero 
<A HREF="kdu$1essor__start.html#num_components">num_components</A> argument is supplied, this is the number of components
you will push to 
<A HREF="kdu$1essor__push_stripe__1.html">push_stripe</A> &mdash; if there are not sufficient components, the
machinery will generate an appropriate error message
through 
<A HREF="kdu_error.html">kdu_error</A>. For more on this, consult the description of the
<A HREF="kdu$1lysis.html">kdu_multi_analysis</A> object on which this is built.
</P>
</DIV>
<H4><A NAME="want_fastest">want_fastest</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
<P>
If this argument is true and 
<A HREF="kdu$1essor__start.html#force_precise">force_precise</A> is false, the function selects a 16-bit internal representation
(usually leads to the fastest processing) even if this
will result in reduced image quality, at least for
irreversible processing. For image components which
require reversible compression, the 32-bit representation
must be selected if the image sample precision is too
high, or else numerical overflow might occur.
</P>
</DIV>
<H4><A NAME="env">env</A> [<A HREF ="kdu$d_env.html">kdu_thread_env</A>&nbsp;*]</H4><DIV CLASS="indented-text">
<P>
This argument is used to establish multi-threaded processing.
For a discussion of the multi-threaded processing features
offered by the present object, see the introductory
comments to 
<A HREF="kdu$1essor.html">kdu_stripe_compressor</A>. We remind you here, however, that all calls to 
<A HREF="kdu$1essor__start.html">start</A>, 
<A HREF="kdu$1essor__push_stripe__1.html">push_stripe</A> and 
<A HREF="kdu$1essor__finish.html">finish</A> must be executed from the same thread, which is identified
only in this function, except where those functions
explicitly provide a non-NULL 
<B>alt_env</B> argument &mdash; see 
<A HREF="kdu$1essor__finish.html">finish</A> for a discussion of this.
</P><P>
 If you re-use the object to process a subsequent image,
you may change threads between the two uses, passing
the appropriate 
<A HREF="kdu$d_env.html">kdu_thread_env</A> reference in each call to 
<A HREF="kdu$1essor__start.html">start</A>.
</P><P>
 If the 
<A HREF="kdu$1essor__start.html#env">env</A> argument is NULL, all processing is single threaded.
Different threads can potentially invoke the 
<A HREF="kdu$1essor__start.html">start</A>, 
<A HREF="kdu$1essor__push_stripe__1.html">push_stripe</A> and 
<A HREF="kdu$1essor__finish.html">finish</A> functions but they must be serialized by the application
so that it is not possible to have any more than one
thread working on any of the compression tasks at once.
</P>
</DIV>
<H4><A NAME="env_queue">env_queue</A> [<A HREF ="kdu$2queue.html">kdu_thread_queue</A>&nbsp;*]</H4><DIV CLASS="indented-text">
<P>
This argument is ignored unless 
<A HREF="kdu$1essor__start.html#env">env</A> is non-NULL, in which case a non-NULL 
<A HREF="kdu$1essor__start.html#env_queue">env_queue</A> means that all multi-threaded processing queues created
inside the present object, by calls to 
<A HREF="kdu$1essor__push_stripe__1.html">push_stripe</A>, should be created as sub-queues of the identified
<A HREF="kdu$1essor__start.html#env_queue">env_queue</A>.
</P><P>
 Note that 
<A HREF="kdu$1essor__start.html#env_queue">env_queue</A> is not detached from the multi-threaded environment
(identified by 
<A HREF="kdu$1essor__start.html#env">env</A>) when the current object is destroyed, or by 
<A HREF="kdu$1essor__finish.html">finish</A>. It is, therefore, possible to have other 
<A HREF="kdu$1essor.html">kdu_stripe_compressor</A> objects (or indeed any other processing machinery)
share this 
<A HREF="kdu$1essor__start.html#env_queue">env_queue</A>.
</P>
</DIV>
<H4><A NAME="env_dbuf_height">env_dbuf_height</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
<P>
This argument may be used to introduce and control
parallelism in the DWT processing steps, allowing you
to distribute the load associated with multiple tile-components
across multiple threads. In the simplest case, this
argument is 0, and parallel processing applies only
to the block encoding processes. For a small number
of processors, this is usually sufficient to keep all
CPU's active. If this argument is non-zero, however,
the 
<A HREF="kdu$1lysis.html">kdu_multi_analysis</A> objects on which all processing is based, are created
with 
<B>double_buffering</B> equal to true and a 
<B>processing_stripe_height</B> equal to the value supplied for this argument. See
<A HREF="kdu$1lysis__create__1.html">kdu_multi_analysis::create</A> for a more comprehensive discussion of double buffering
principles and guidelines.
</P><P>
 Note that the special value -1 is particularly useful,
as it allows the internal machinery to select a good
double buffering stripe height automatically. In the
case where the codestream contains multiple horizontally
adjacent tiles and the stripes pushed into the 
<B>push</B> function correspond to whole tile rows (preferable
and likely to occur if you use the 
<A HREF="kdu$1essor__get$_heights.html">get_recommended_stripe_heights</A> function to determine good stripe heights) the best
policy is usually to use an 
<A HREF="kdu$1essor__start.html#env_dbuf_height">env_dbuf_height</A> value that is at least half the tile height. Otherwise,
the best value is usually closer to 30 or 40. Given
these complexities, it is usually best to pass -1 for
this argument (the default) so that the internal machinery
is free to make these sort of decisions itself.
</P>
</DIV>
<H4><A NAME="env_tile_concurrency">env_tile_concurrency</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
<P>
This argument is of interest when compressing codestreams
with many small tiles, with multi-threaded processing
(
<A HREF="kdu$1essor__start.html#env">env</A> != NULL). It is especially interesting where the stripe
height used for processing is equal to (or a multiple
of) the tile height, so that each call to 
<A HREF="kdu$1essor__push_stripe__1.html">push_stripe</A> results in the opening and closing of tiles one by
one. Rather than closing a tile as soon as all samples
have been pushed into its 
<A HREF="kdu$1lysis.html">kdu_multi_analysis</A> processing engine, the internal machinery keeps a
list of up to 
<A HREF="kdu$1essor__start.html#env_tile_concurrency">env_tile_concurrency</A>-1 such "finished" tiles around. This means that in
cases where tiles are opened, processed and closed
one by one, the total number of concurrently active
tiles is given by 
<A HREF="kdu$1essor__start.html#env_tile_concurrency">env_tile_concurrency</A>. Larger values of 
<A HREF="kdu$1essor__start.html#env_tile_concurrency">env_tile_concurrency</A> increase the likelihood that when the call to 
<B>push</B> must join upon completion of the least recently finished
tile, the join succeeds immediately. On the other hand,
increasing the tile concurrency obviously also increases
working memory; it may also slightly reduce the distributed
job scheduling efficiency in the internal system.
</P><P>
 If the value passed for this argument is less than
or equal to 0, the internal machinery automatically
selects a reasonable tile concurrency level. The algorithm
used to do this may be very simple, but may also evolve
over time, so it is always worth testing the performance
of your application with a variety of different values
for this argument.
</P><P>
 Whatever value is passed for this argument, the actual
value used internally is limited to at most 1 more
than the number of tiles spanned by the image width,
so that the maximum number of finished tiles that are
kept around is no more than the number of tiles across
the image.
</P><P>
 If the pushed stripes are not high enough to span
an entire row of tiles, the impact of this argument
is slightly different. In this case, the internal machinery
always needs to keep an entire row of open tiles with
active tile processing engines. If the 
<A HREF="kdu$1essor__start.html#env_tile_concurrency">env_tile_concurrency</A> argument is not equal to 1, the function also keeps
the previous row of tile processing engines open as
well, so that their internal processing jobs can complete
while the current row of tiles is being started.
</P><P>
 For maximum multi-threaded processing efficiency when
working with small tiles, you should push stripes whose
height is exactly one tile height, setting 
<A HREF="kdu$1essor__start.html#env_dbuf_height">env_dbuf_height</A> equal to half the stripe height (or a little more)
and setting 
<A HREF="kdu$1essor__start.html#env_tile_concurrency">env_tile_concurrency</A> to a modest number (e.g., 4). The 
<A HREF="kdu$1essor__start.html#env_dbuf_height">env_dbuf_height</A> strategy is implemented automatically if you pass
-1 for that argument, which is usually best and simplest.
The 
<B>env_tile_concurrentcy</B> strategy is also likely to be implemented automatically
if you pass 0 or a a negative value for this argument.
The reason for selecting such a large DWT double buffering
size for images with lots of small tiles is that it
allows each tile processing engine to buffer all samples
in its tile so that the main thread is not held up
waiting for the tile to be processed. This allows all
<A HREF="kdu$1essor__start.html#env_tile_concurrency">env_tile_concurrency</A> concurrently open tiles to offer processing jobs for
the worker threads to complete. The internal machinery
ensures that the tile processing engines are prioritised
by assigning increasing sequence indices to each engine's
<A HREF="kdu$2queue.html">kdu_thread_queue</A>, so that tiles almost certainly complete in order.
</P>
</DIV>
<H4><A NAME="trim_to_rate">trim_to_rate</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
<P>
This argument is passed through to 
<A HREF="kdu$tream__flush.html">kdu_codestream::flush</A> and 
<A HREF="kdu$tream__auto_flush.html">kdu_codestream::auto_flush</A>, when they are used internally, indicating whether
or not the final codestream flushing operation should
make a final rate control pass through all available
code-blocks to determine whether any of them can add
an extra coding pass to the final quality layer in
such a way as to use up any byte limit communicated
via the last entry in 
<A HREF="kdu$1essor__start.html#layer_sizes">layer_sizes</A>. This argument is irrelevant unless the 
<A HREF="kdu$1essor__start.html#layer_sizes">layer_sizes</A>, 
<A HREF="kdu$1essor__start.html#layer_slopes">layer_slopes</A> and 
<A HREF="kdu$1essor__start.html#flush_flags">flush_flags</A> parameters indicate that rate control will be based
on byte limits. It is also irrelevant if the final
entry in 
<A HREF="kdu$1essor__start.html#layer_sizes">layer_sizes</A> is 0 (unlimited) or there is no such entry (e.g.,
<A HREF="kdu$1essor__start.html#num_layer_specs">num_layer_specs</A>=0 or 
<A HREF="kdu$1essor__start.html#layer_sizes">layer_sizes</A>=NULL).
</P>
</DIV>
<H4><A NAME="flush_flags">flush_flags</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
<P>
This argument affects the interpretation of the 
<A HREF="kdu$1essor__start.html#layer_sizes">layer_sizes</A> and 
<A HREF="kdu$1essor__start.html#layer_slopes">layer_slopes</A> arguments in cases where both are non-NULL. The argument
is passed to 
<A HREF="kdu$tream__flush.html">kdu_codestream::flush</A> and related functions, such as 
<A HREF="kdu$tream__auto_flush.html">kdu_codestream::auto_flush</A>, where the interpretation of the flags is discussed
in detail. The key flags are 
<A HREF="globals.html#KDU_FLUSH_THRESHOLDS_ARE_HINTS">KDU_FLUSH_THRESHOLDS_ARE_HINTS</A> and 
<A HREF="globals.html#KDU_FLUSH_USES_THRESHOLDS_AND_SIZES">KDU_FLUSH_USES_THRESHOLDS_AND_SIZES</A>, but others may be defined in the future. See the
descriptions of 
<A HREF="kdu$1essor__start.html#layer_sizes">layer_sizes</A> and 
<A HREF="kdu$1essor__start.html#layer_slopes">layer_slopes</A> above for more on how these flags affect their interaction.
</P>
</DIV>
<H4><A NAME="multi_xform_extra_params">multi_xform_extra_params</A> [const&nbsp;<A HREF ="kdu$1arams.html">kdu_push_pull_params</A>&nbsp;*]</H4><DIV CLASS="indented-text">
<P>
This optional argument is passed along internally to
the 
<A HREF="kdu$1lysis__create__1.html">kdu_multi_analysis::create</A> function when it is called to set up each tile processing
engine, which may give you extra control over the internal
operation of the compression machinery.
</P>
</DIV>
</DIV>

<P ALIGN="CENTER"><HR></P><P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$1essor__~kd$mpressor.html"> prev </A>||<A HREF="kdu$1essor__get$sequence.html"> next </A>|</P>
</BODY>
</HTML>
