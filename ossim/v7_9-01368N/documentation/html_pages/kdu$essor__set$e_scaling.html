<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (kdu_region_decompressor::set_true_scaling) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
.function-text { padding-left: 80pt;
                 text-indent: -60pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#B4DCB4">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$essor__get$mage_dims__2.html"> prev </A>||<A HREF="kdu$essor__set$e_stretch.html"> next </A>|</P>
<H1><A NAME="ToP">kdu_region_decompressor::set_true_scaling</A></H1>
<DIR><DIR><H3><EM><U>Java:</U> Kdu_region_decompressor.Set_true_scaling</EM></H3></DIR></DIR>
<P CLASS="function-text"><B>void</B> set_true_scaling(
<B>bool</B>&nbsp;true_zero,
<B>bool</B>&nbsp;true_max)</P>
<DIR><DIR><P CLASS="function-text"><EM><U>Java:</U> public native void Set_true_scaling(
boolean&nbsp;true_zero,
boolean&nbsp;true_max)</EM></P></DIR></DIR>
<P><A HREF="kdu$essor.html">Go to class description.</A></P>

<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
For predictable behaviour, you should call this function
only while the object is inactive &mdash; i.e., before
the first call to 
<A HREF="kdu$essor__start.html">start</A>, or after the most recent call to 
<A HREF="kdu$essor__finish.html">finish</A> and before any subsequent call to 
<A HREF="kdu$essor__start.html">start</A>.
</P><P>
 The function sets up the "true scaling" mode which
will become active when 
<A HREF="kdu$essor__start.html">start</A> is next called. The same "true scaling" mode will
be used in each subsequent call to 
<A HREF="kdu$essor__start.html">start</A> unless the present function is used to change it.
Note that calls to this function cancel the effect
of any prior call to 
<A HREF="kdu$essor__set$e_stretch.html">set_white_stretch</A>; indeed that function is no longer recommended, since
this function subsumes and substantially builds upon
its role.
</P><P>
 This function is introduced to provide the application
with more control over the way in which sample values
get scaled, and perhaps offset, as part of the rendering
pipeline. The function can make a difference to the
way sample values identified as holding a signed representation
are handled, as opposed to the vastly more common unsigned
representation. The function can also make a difference
to the values returned by the 
<A HREF="kdu$essor__process__1.html">process</A> functions where the precision of the returned data
differs from that originally identified in the source
codestream. For common cases, where original samples
had an original unsigned representation and the 
<A HREF="kdu$essor__process__1.html">process</A> function returns samples with the same (i.e., native,
or default) precision, the "true scaling" options discussed
here make no difference.
</P><P>
 At an elementary level, you can understand the 
<A HREF="kdu$essor__set$e_scaling.html#true_zero">true_zero</A> and 
<A HREF="kdu$essor__set$e_scaling.html#true_max">true_max</A> modes as follows. The objective of the 
<A HREF="kdu$essor__set$e_scaling.html#true_max">true_max</A> mode is to ensure that the maximum representable intensity
of an input sample is mapped exactly to the maximum
representable intensity of the output sample, regardless
of their precisions. This usually requires floating
point conversion and multiplications, which can add
to the computational complexity of the overall process
relative to the default policy of using bit shifts
alone. In most cases, bit shifts yield very close approximations
to the true-max mapping. The objective of the 
<A HREF="kdu$essor__set$e_scaling.html#true_zero">true_zero</A> mode is to ensure that the natural representation
for zero intensity (or the achromatic level for chrominance
channels) is preserved by mappings across different
precisions and between signed and unsigned representations.
The main impact of 
<A HREF="kdu$essor__set$e_scaling.html#true_zero">true_zero</A> is that signed original sample values have their zero
point mapped to zero (or black) of an unsigned output
representation, rather than to a mid-level grey value,
which is the default. The 
<A HREF="kdu$essor__set$e_scaling.html#true_zero">true_zero</A> mode has a subtle impact on the mapping of colour
channels for which the natural zero point of an unsigned
representation is something other than 0, as explained
more carefully below.
</P><P>
 The 
<A HREF="kdu$essor__set$e_scaling.html#true_zero">true_zero</A> option determines how signed sample values are handled.
The JPEG2000 standards assign image components a representation
involving a precision (or bit-depth) P, either as signed
or unsigned integers. This happens at the codestream
and file format levels and applies also where palette
lookup tables are involved. Unsigned sample values
are generally offset by subtracting 2^{P-1} for the
purpose of better utilizing the dynamic range afforded
by numeric quantities in the compression and decompression
processing. Also, except where compression is truly
reversible (required only for truly lossless compression),
all computations are generally best performed using
fixed-point or floating-point arithmetic, abandoning
a strict connection with integers. With this in mind,
all sample values and palette entries can be thought
of as taking values x in the range -0.5 to 0.5, where
all unsigned values have been level offset and values
that are processed as absolute integers are related
to x through multiplication by 2^P. The default mechanism
for mapping all such representations to rendered intensity
values is to multiply (x+0.5) by 2^B for unsigned outputs
and x by 2^B for signed outputs, where B is the target
precision associated with the relevant 
<A HREF="kdu$essor__process__1.html">process</A> call &mdash; unsigned outputs are always the default.
This means that sample values that were originally
signed prior to compression have their zero point mapped
to a mid-level grey, allowing both negative and positive
deviations from zero to be visualized.
</P><P>
 Passing 
<A HREF="kdu$essor__set$e_scaling.html#true_zero">true_zero</A>=true in this function modifies the default policy,
so that the "natural zero point" always maps to the
"natural zero point". The natural zero point for a
signed quantity is always taken to be 0, while the
natural zero point for an unsigned quantity is normally
also 0. An exception occurs with samples that represent
chominance components in an opponent colour space such
as YCbCr. Chrominance components are most commonly
represented as unsigned integers with a natural zero
point of 2^{P-1}, where P is the precision. More generally,
associated with every channel the natural zero point
for unsigned representations is expressed as a relative
parameter \zeta, that is derived from the colour space.
For opacity channels and the colour channels of most
colour spaces, \zeta=0. For chrominance channels of
typical opponent colour spaces, \zeta=0.5. An exception
is the CIEL*a*b* colour space, for which the a* channel
usually has \zeta=0.5 but the b* channel usually has
\zeta=0.375. The natural zero point for an unsigned
P-bit integer is then \zeta * 2^P. Below we give the
"true zero" conversion equations for the case where
<A HREF="kdu$essor__set$e_scaling.html#true_max">true_max</A>=false. The 
<A HREF="kdu$essor__set$e_scaling.html#true_max">true_max</A>=true case is considered later on.
</P><UL><LI>
In the 
<A HREF="kdu$essor__set$e_scaling.html#true_zero">true_zero</A> mode, an originally signed sample whose relative decompressed
value x has the nominal range -0.5 to +0.5 is mapped
to a B-bit unsigned output Y through Y = 2^B * [\zeta
+ x * (1-\zeta) / 0.5]. In the common case where \zeta=0,
this becomes Y = x * 2^{B+1}. If \zeta=0.5, it becomes
Y = (x+0.5) * 2^B. In every case, of course, the output
needs to be clipped to the range 0 to 2^B-1.
</LI><LI>
In the 
<A HREF="kdu$essor__set$e_scaling.html#true_zero">true_zero</A> mode, an originally unsigned sample whose relative
decompressed value x has the nominal range -0.5 to
+0.5 is mapped to a B-bit signed output Y through Y
= 2^B * (x + 0.5 - \zeta) * 0.5 / (1-\zeta). With \zeta=0,
this becomes Y = (x+0.5)*2^{B-1}, while when \zeta=0.5
it becomes Y = x * 2^B.
</LI></UL><P>
 Notice that both the default and "true-zero" mappings
for just about any situation can be accommodated using
bit-shifts alone so long as the 
<A HREF="kdu$essor__set$e_scaling.html#true_max">true_max</A> option is not asserted (see below). The only exceptions
to this occur where zeta is neither 0 nor 0.5, for
which the conversion is more complex.
</P><P>
 As mentioned above, the 
<A HREF="kdu$essor__set$e_scaling.html#true_max">true_max</A> option enforces the mapping of the true maximum value
of an input representation exactly to the true maximum
value of the output representation. This primarily
affects transformations between samples of different
precisions, but it also impacts conversions between
signed and unsigned representations when the 
<A HREF="kdu$essor__set$e_scaling.html#true_zero">true_zero</A> mode is asserted. Specifically, observe that although
the level-offset relative decompressed sample values
x lie in the range -0.5 to +0.5, the actual maximum
value that should be expected in the absence of any
compression distortion is x = 0.5-2^{-P}. Meanwhile,
the maximum value of a B-bit unsigned output is 2^B-1,
while the maximum value of a B-bit signed output is
2^{B-1}-1. Putting these together, we can describe
the 
<A HREF="kdu$essor__set$e_scaling.html#true_max">true_max</A> conversion operations with and without 
<A HREF="kdu$essor__set$e_scaling.html#true_zero">true_zero</A> as folows:
</P><P>
 If 
<A HREF="kdu$essor__set$e_scaling.html#true_max">true_max</A>=true and 
<A HREF="kdu$essor__set$e_scaling.html#true_zero">true_zero</A>=false, the scaling policy aims to stretch unsigned
inputs into the full range of outputs. For signed inputs,
the approach is similar, but the positive part of the
range of inputs is stretched into the corresponding
part of the output range. For B-bit-outputs Y and the
level-offset relative inputs x, this means the following:
</P><UL><LI>
If input and output are both unsigned, Y = 2^B * (x+0.5)
* (1-2^{-B}) / (1-2^{-P}).
</LI><LI>
If input is unsigned but output is signed, Y = 2^B
* (x+0.5) * (1-2^{-B}) / (1-2^{-P}) - 2^{B-1}.
</LI><LI>
If input is signed and output unsigned, Y = 2^B * x
* (0.5-2^{-B}) / (0.5-2^{-P}) + 2^{B-1}.
</LI><LI>
If input and output are both signed, Y = 2^B * x *
(0.5-2^{-B}) / (0.5-2^{-P}).
</LI></UL><P>
 If 
<A HREF="kdu$essor__set$e_scaling.html#true_max">true_max</A> and 
<A HREF="kdu$essor__set$e_scaling.html#true_zero">true_zero</A> are true, the following relationships hold for signed
or unsigned B-bit outputs Y and level-offset relative
inputs x:
</P><UL><LI>
If input and output are both unsigned, Y=2^B*[\zeta+(x+0.5-\zeta)*(1-2^{-B}-\zeta)/(1-2^{-P}-\zeta)].
</LI><LI>
If input and output are both signed, Y = x * 2^B *
(0.5 - 2^{-B}) / (0.5 - 2^{-P}).
</LI><LI>
If inputs are signed and outputs unsigned, Y = 2^B
* [\zeta + x * (1-2^{-B}-\zeta) / (0.5-2^{-P})].
</LI><LI>
If inputs are unsigned and outputs are signed, Y =
2^B * (x+0.5-\zeta) * (0.5-2^{-B}) / (1-2^{-P}-\zeta)
</LI></UL><P>
 The above, "true scaling" configuration, is defined
in IS15444-2/AMD3 to be the correct interpretation
for rendering of JPX images, but it has some drawbacks
in regard to the visualisation of signed imagery and
it is not necessarily suitable for applications that
use higher bit-depth B-bit targets simply as a common
encapsulation mechanism for decoded data. For such
applications, or for those which require backward compatibility
with the Kakadu versions prior to 7.8, the default
interpretation with 
<A HREF="kdu$essor__set$e_scaling.html#true_zero">true_zero</A> and 
<A HREF="kdu$essor__set$e_scaling.html#true_max">true_max</A> both false, is more appropriate.
</P><P>
 We now consider the impact of the "true scaling" options
on input sample representations that cannot be interpreted
as P-bit signed or unsigned integers. Input values
with non-integer representations occur when the 
<B>data_format</B> returned by 
<A HREF="jp2$nnels__get$r_mapping.html">jp2_channels::get_colour_mapping</A> is not 
<A HREF="globals.html#JP2_CHANNEL_FORMAT_DEFAULT">JP2_CHANNEL_FORMAT_DEFAULT</A>. The two non-default formats that are handled by this
object are 
<A HREF="globals.html#JP2_CHANNEL_FORMAT_FIXPOINT">JP2_CHANNEL_FORMAT_FIXPOINT</A> and 
<A HREF="globals.html#JP2_CHANNEL_FORMAT_FLOAT">JP2_CHANNEL_FORMAT_FLOAT</A>.
</P><UL><LI>
Fixed-point inputs behave as if P were infinite in
the above expressions, and x (signed) or x+0.5 (unsigned)
must additionally be scaled by 2^{-I}, where I is the
number of integer bits in the floating point representation.
</LI><LI>
After conversion of integer bit patterns to floats,
<A HREF="globals.html#JP2_CHANNEL_FORMAT_FLOAT">JP2_CHANNEL_FORMAT_FLOAT</A> formatted inputs result in floating point values for
which P can again be considered infinite in the expressions
above. Unsigned floats notionally have a nominal range
from 0 to 1.0, but we internally subtract 0.5 and then
treat them exactly as above. Signed floats notionally
have a nominal range from -1.0 to +1.0, but we internally
scale by 0.5 and then treat them exactly as above.
</LI></UL><P>
 We finish by identifying some special cases where
the "true-max" scaling policy applies regardless of
whether this function or 
<A HREF="kdu$essor__set$e_stretch.html">set_white_stretch</A> are ever called &mdash; the same is not true of the
<A HREF="kdu$essor__set$e_scaling.html#true_zero">true_zero</A> scaling attribute, which is attainable only by calling
this function. There are three such special cases,
as follows:
</P><UL><LI>
<A HREF="globals.html#JP2_CHANNEL_FORMAT_FLOAT">JP2_CHANNEL_FORMAT_FLOAT</A>-formatted input samples are always mapped according
to the "true-max" policy.
</LI><LI>
<B>JP2_CHANNEL_FIXPOINT</B>-formatted input samples that have anything other than
0 integer bits are always mapped according to the "true-max"
policy. If the number of integer bits is 0, fixpoint-formatted
input samples have almost exactly the same interpretation
as regular integer-formatted data.
</LI><LI>
Some variants of the 
<A HREF="kdu$essor__process__1.html">process</A> function produce floating point outputs. These functions
also behave as if "true-max" were asserted, regardless
of how this or any other function is called.
</LI></UL><P>
 To extend your understanding of how the various sample
value scaling and offset algorithms are applied, you
may find it instructive to review the documentation
for the 
<A HREF="kdu$nterp.html">kdu_channel_interp</A> structure and the 
<A HREF="jp2$nnels__get$r_mapping.html">jp2_channels::get_colour_mapping</A> function. In fact correct implementation of the policies
described above relies upon the 
<A HREF="kdu$nterp.html">kdu_channel_interp</A> structures found in the 
<A HREF="kdu$pping.html#channel_interp">kdu_channel_mapping::channel_interp</A> array retaining the values with which they are initialized
by the various 
<A HREF="kdu$pping__configure__1.html">kdu_channel_mapping::configure</A> functions, even though it is strictly possible for
an application to modify these values.
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="ArgS">Arguments</A></H2><DIV CLASS="indented-text">
<H4><A NAME="true_zero">true_zero</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
</DIV>
<H4><A NAME="true_max">true_max</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
</DIV>
</DIV>

<P ALIGN="CENTER"><HR></P><P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$essor__get$mage_dims__2.html"> prev </A>||<A HREF="kdu$essor__set$e_stretch.html"> next </A>|</P>
</BODY>
</HTML>
