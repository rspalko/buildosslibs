<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (kdu_region_decompressor::process) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
.function-text { padding-left: 80pt;
                 text-indent: -60pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#B4DCB4">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$essor__process__2.html"> prev </A>||<A HREF="kdu$essor__process__4.html"> next </A>|</P>
<H1><A NAME="ToP">kdu_region_decompressor::process</A></H1>
<P>Overload navigation: <B><A HREF="kdu$essor__process__1.html">1</A>,
<A HREF="kdu$essor__process__2.html">2</A>,
3,
<A HREF="kdu$essor__process__4.html">4</A>,
<A HREF="kdu$essor__process__5.html">5</A>,
<A HREF="kdu$essor__process__6.html">6</A>,
<A HREF="kdu$essor__process__7.html">7</A></B></P>
<P CLASS="function-text"><B>bool</B> process(
<B>float</B>&nbsp;**&nbsp;channel_buffer,
<B>bool</B>&nbsp;expand_monochrome,
<B>int</B>&nbsp;pixel_gap,
<A HREF ="kdu_coords.html">kdu_coords</A>&nbsp;buffer_origin,
<B>int</B>&nbsp;row_gap,
<B>int</B>&nbsp;suggested_increment,
<B>int</B>&nbsp;max_region_pixels,
<A HREF ="kdu_dims.html">kdu_dims</A>&nbsp;&amp;&nbsp;incomplete_region,
<A HREF ="kdu_dims.html">kdu_dims</A>&nbsp;&amp;&nbsp;new_region,
<B>bool</B>&nbsp;normalize=true,
<B>bool</B>&nbsp;measure_row_gap_in_pixels=true,
<B>bool</B>&nbsp;always_clip_outputs=true)</P>
<P><A HREF="kdu$essor.html">Go to class description.</A></P>

<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
Same as the first and second forms of the overloaded
<A HREF="kdu$essor__process__1.html">process</A> function, except that the channel buffers employ a
floating point representation. As with those functions,
it is possible to select arbitrary 
<B>channel_offsets</B> so that the organization of 
<B>buffer</B> need not necessarily be interleaved component-by-component.
</P><P>
 To get data with sufficient accuracy to deserve a
floating point representation, you might like to set
the 
<B>precise</B> argument to true in the call to 
<A HREF="kdu$essor__start.html">start</A>.
</P><P>
 One important difference between this function and
the integer-based 
<A HREF="kdu$essor__process__1.html">process</A> functions is that some form of white stretching is
always employed. Specifically, the nominal range of
the original sample values used to create each channel
is stretched to the full dynamic range associated with
the floating point result. This is equivalent to asserting
the "true-max" mode that is described in connection
with the 
<A HREF="kdu$essor__set$e_scaling.html">set_true_scaling</A> function, irrespective of whether that function is
explicitly called or not. You can call 
<A HREF="kdu$essor__set$e_stretch.html">set_white_stretch</A> if you like, but it is strongly discouraged, since
that may result int the internal concatenation of two
white stretching steps, one of which is redundant.
</P><P>
 A second important difference between this function
and the integer-based ones is that this function allows
the extra head-room associated with non-default source
pixel formats suitable for HDR content to be preserved,
by passing 
<A HREF="kdu$essor__process__3.html#always_clip_outputs">always_clip_outputs</A>=false. The integer-based 
<A HREF="kdu$essor__process__1.html">process</A> functions always clip their outputs to the expected
nominal range, so that the processed content can be
used immediately by a rendering application. The floating-point
<A HREF="kdu$essor__process__1.html">process</A> functions do the same thing if 
<A HREF="kdu$essor__process__3.html#always_clip_outputs">always_clip_outputs</A>=true or if the original source content is identified
as having integer-formatted samples (typical). If a
JPX pixel format (pxfm) box was present, the original
samples can be identified as integer bit-patterns that
represent floating point numbers, or fixed-point numbers
with varying numbers of fraction bits (equivalently
varying numbers of integer bits). If 
<A HREF="kdu$essor__process__3.html#always_clip_outputs">always_clip_outputs</A> is false, float-formatted source content or fixpoint-formatted
content with a non-zero number of integer bits will
not be clipped to the expected bounds. This is because
these more exotic input formats can be used to represent
super-luminous regions of HDR content (or perhaps just
scientific data with unknown numerical range) that
should not be clipped.
</P><P>
 If 
<A HREF="kdu$essor__process__3.html#normalize">normalize</A> is true, the output dynamic range is from 0 to 1.0,
inclusive; thus, if original samples had an 8-bit dynamic
range (as originally compressed), they would effectively
be divided by 255.0 to produce normalized floating
point output samples.
</P><P>
 If 
<A HREF="kdu$essor__process__3.html#normalize">normalize</A> is false, the output dynamic range depends upon the
default rendering precision and signed/unsigned information
found in the 
<A HREF="kdu$pping.html">kdu_channel_mapping</A> object supplied to 
<A HREF="kdu$essor__start.html">start</A>. For more on this, see the 
<A HREF="kdu$essor__process__3.html#normalize">normalize</A> argument.
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="ArgS">Arguments</A></H2><DIV CLASS="indented-text">
<H4><A NAME="channel_buffer">channel_buffer</A> [<B>float</B>&nbsp;**]</H4><DIV CLASS="indented-text">
</DIV>
<H4><A NAME="expand_monochrome">expand_monochrome</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
</DIV>
<H4><A NAME="pixel_gap">pixel_gap</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
</DIV>
<H4><A NAME="buffer_origin">buffer_origin</A> [<A HREF ="kdu_coords.html">kdu_coords</A>]</H4><DIV CLASS="indented-text">
</DIV>
<H4><A NAME="row_gap">row_gap</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
</DIV>
<H4><A NAME="suggested_increment">suggested_increment</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
</DIV>
<H4><A NAME="max_region_pixels">max_region_pixels</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
</DIV>
<H4><A NAME="incomplete_region">incomplete_region</A> [<A HREF ="kdu_dims.html">kdu_dims</A>&nbsp;&amp;]</H4><DIV CLASS="indented-text">
</DIV>
<H4><A NAME="new_region">new_region</A> [<A HREF ="kdu_dims.html">kdu_dims</A>&nbsp;&amp;]</H4><DIV CLASS="indented-text">
</DIV>
<H4><A NAME="normalize">normalize</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
<P>
If true, the 
<B>buffer</B> samples are all normalized to lie within the closed
interval [0,1]. Exactly what this means when the original
samples are identified as signed, rather than unsigned,
depends on the 
<B>true_zero</B> mode, as explained with the 
<A HREF="kdu$essor__set$e_scaling.html">set_true_scaling</A> function. In the default case, the original signed
values in the range -2^{P-1} to 2^{P-1}-1 are mapped
directly to the interval [0,1], so that an input value
of zero maps to a floating point output value of 0.5.
I 
<B>true_zero</B> is asserted, however, originally signed values in
the range 0 to 2^{P-1} are mapped to [0,1], truncating
all negative values to 0. For a much more thorough
discussion of "true-zero" mapping, read the extensive
comments found with the 
<A HREF="kdu$essor__set$e_scaling.html">set_true_scaling</A> function.
</P><P>
 If the 
<A HREF="kdu$essor__process__3.html#normalize">normalize</A> argument is false, the behaviour is similar to that
described above, except that the nominal range of the
source data is stretched into the range [Pmin, Pmax],
where Pmin and Pmax depend on the 
<A HREF="kdu$pping.html#default_rendering_precision">kdu_channel_mapping::default_rendering_precision</A> and 
<A HREF="kdu$pping.html#default_rendering_signed">kdu_channel_mapping::default_rendering_signed</A> arrays found in the 
<A HREF="kdu$pping.html">kdu_channel_mapping</A> object supplied to 
<A HREF="kdu$essor__start.html">start</A>. Specifically, if P is the default rendering precision
for the channel, as determined from the 
<A HREF="kdu$pping.html">kdu_channel_mapping</A> object, and the default rendering information identifies
unsigned sample values, [Pmin,Pmax] is equal to [0,(2^P)-1].
</P><P>
 In the event that the default rendering information
identifies signed sample values for the channel, [Pmin,Pmax]
is set to [-2^{P-1},2^{P-1}-1], except where P=0. In
the P=0 case, [Pmin,Pmax]=[-0.5,0.5] for signed samples,
while [Pmin,Pmax]=[0,1] for unsigned samples.
</P><P>
 Note that the default rendering information in 
<A HREF="kdu$pping.html">kdu_channel_mapping</A> is initialized by the 
<A HREF="kdu$pping__configure__1.html">kdu_channel_mapping::configure</A> function to represent the native bit-depths and signed/unsigned
properties of the original image samples (or palette
indices). For sample data whose identified pixel format
is 
<A HREF="globals.html#JP2_CHANNEL_FORMAT_FLOAT">JP2_CHANNEL_FORMAT_FLOAT</A> (see 
<A HREF="jp2$nnels__set$r_mapping.html">jp2_channels::set_colour_mapping</A> and/or 
<A HREF="kdu$nterp.html">kdu_channel_interp</A>), the default rendering precision is set to 0, which
yields the nominal ranges [0,1] and [-0.5,0.5] for
non-normalized unsigned and signed outputs, as explained
above. For sample data whose identified as 
<A HREF="globals.html#JP2_CHANNEL_FORMAT_FIXPOINT">JP2_CHANNEL_FORMAT_FIXPOINT</A> (see 
<A HREF="jp2$nnels__set$r_mapping.html">jp2_channels::set_colour_mapping</A> and/or 
<A HREF="kdu$nterp.html">kdu_channel_interp</A>), the default rendering precision is set to F, where
F is the number of fraction bits, being P minus the
number of integer bits. This is consistent with the
notion that values outside the expected range should
be those having extra-ordinary luminosity, requiring
the head-room afforded by the non-default pixel format.
</P><P>
 Regardless of how 
<B>configure</B> initializes the 
<A HREF="kdu$pping.html#default_rendering_precision">kdu_channel_mapping::default_rendering_precision</A> and 
<A HREF="kdu$pping.html#default_rendering_signed">kdu_channel_mapping::default_rendering_signed</A> arrays, however, you can always explicitly set your
own values so as to control the nominal range associated
with the values returned by this function. If no 
<A HREF="kdu$pping.html">kdu_channel_mapping</A> object was supplied to 
<A HREF="kdu$essor__start.html">start</A>, the default rendering precision and signed/unsigned
characteristics are derived from the original properties
of the image samples represented by the code-stream.
</P>
</DIV>
<H4><A NAME="measure_row_gap_in_pixels">measure_row_gap_in_pixels</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
</DIV>
<H4><A NAME="always_clip_outputs">always_clip_outputs</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
<P>
Defaults to true, so that renderers not capable of
handling unexpected values need not worry. However,
as explained above, if you pass false for this argument,
this function will preserve the extra head-room associated
with the special float or fixpoint formats that can
be signalled via the JPX pixel format (pxfm) box. This
is mainly important for HDR rendering applications,
or applications intended to render scientific data
that might have been compressed as true floats, without
any natural range bounds.
</P>
</DIV>
</DIV>

<P ALIGN="CENTER"><HR></P><P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$essor__process__2.html"> prev </A>||<A HREF="kdu$essor__process__4.html"> next </A>|</P>
</BODY>
</HTML>
