<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (kdu_client::get_timed_request_horizon) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
.function-text { padding-left: 80pt;
                 text-indent: -60pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#B4DCB4">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ReturnS"> return value </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu_client__sync_timing.html"> prev </A>||<A HREF="kdu_client__tri$requests.html"> next </A>|</P>
<H1><A NAME="ToP">kdu_client::get_timed_request_horizon</A></H1>
<DIR><DIR><H3><EM><U>Java:</U> Kdu_client.Get_timed_request_horizon</EM></H3></DIR></DIR>
<P CLASS="function-text"><B>kdu_long</B> get_timed_request_horizon(
<B>int</B>&nbsp;queue_id,
<B>bool</B>&nbsp;expect_preemptive)</P>
<DIR><DIR><P CLASS="function-text"><EM><U>Java:</U> public native long Get_timed_request_horizon(
int&nbsp;queue_id,
boolean&nbsp;expect_preemptive)</EM></P></DIR></DIR>
<P><A HREF="kdu_client.html">Go to class description.</A></P>

<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
This function is used in conjunction with calls to
<A HREF="kdu_client__post_window.html">post_window</A> that specify a non-zero 
<B>service_usecs</B> argument. It helps the application to avoid posting
more window of interest requests than are necessary
to keep the request queue primed.
</P><P>
 Typically, the application would call this function
each time it receives notification of the arrival of
new data in the client's cache via its 
<A HREF="kdu$ifier.html">kdu_client_notifier</A> object, to determine whether or not additional window
of interest requests should be posted using 
<A HREF="kdu_client__post_window.html">post_window</A>.
</P><P>
 Roughly speaking, the horizon is calculated by starting
with the value Lmax (number of bytes the client aims
to request at once, either in a single request or a
batch of concurrently issued requests), adding the
intended overlap (number of bytes that are still to
be received from a previous request or batch of requests
before a new request is issued), which is Lmax/2 in
the current implementation, removing any outstanding
bytes from earlier requests (requested but not yet
received), dividing by the estimated transmission rate
so as to convert from bytes to microseconds, then subtracting
the service times associated with pending requests
that have been posted but not yet issued to the server.
</P><P>
 Beyond the above rough blueprint, the function also
takes account of accumulated "disparity" between actually
received service times and requested service times.
</P><UL><LI>
If the disparity is positive, the service is running
behind, so requests in the future will have to be issued
more quickly (with lower byte limits) to catch up.
This means that the horizon should be lengthened, because
we will need requests further into the future in order
to accommodate the issuing of deliberately foreshortened
requests, while continuing to keep the channel alive.
</LI><LI>
On the other hand, if the service time disparity is
negative, the service is running ahead, which often
happens when the client already has most or all of
the content being requested within its cache. In this
case, requests will be deliberately lengthened in order
to restore things; however, if the client already has
all available content for a decent chunk of an animation,
this will not help matters, since the server will consistently
return far less information than the client requests,
regardless of how much data is requested. Without any
corrective efforts, this will result in the current
function returning a consistently positive horizon,
because more requests are always required in the vain
attempt to keep the channel alive. While this is OK
for a streaming video service, it is not ideal for
an interactive media browser, since a large number
of requests may need to be wiped out (pre-empted) if
the client's interests change. To address this issue,
the present function implicitly applies a cap on the
degree to which the realized service disparity can
become negative, reducing the returned horizon so as
to enforce this cap. In this way, negative horizons
will eventually be returned, causing the request queue
to empty and the service to go idle for a while. This
idle time counts as unused service time from the perspective
of the flow control algorithm, so that the service
disparity is gradually restored towards zero. While
idling the service may appear to be non-optimal, it
is expected to lead to better overall utilization of
resources, since an interactive user's interests are
likely to change over time, and other JPIP clients
(or queues within the same client) may be able to better
utilize the bandwidth in servicing more immediate needs.
</LI></UL>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="ReturnS">Return Value</A></H2><DIV CLASS="indented-text">
<P>
Returns a threshold on the cumulative number of microseconds
associated with 
<B>service_usecs</B> values passed to new requests (not yet posted) beyond
which there is no need for additional requests to be
posted at the current time to keep the request queue
primed.
</P><P>
 The return value may be 0 or even negative, in which
case there is no need for any new requests to be posted
at the current time.
</P><P>
 In the event that the identified request queue does
not exist, or is not alive, the function is guaranteed
to return a -ve value.
</P>
</DIV>
<H2><A NAME="ArgS">Arguments</A></H2><DIV CLASS="indented-text">
<H4><A NAME="queue_id">queue_id</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
</DIV>
<H4><A NAME="expect_preemptive">expect_preemptive</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
<P>
If true, the caller is expecting its next call to 
<A HREF="kdu_client__post_window.html">post_window</A> to be pre-emptive &mdash; i.e., the first call in
a sequence of timed requests. This makes a difference,
because a pre-emptive call will cancel any outstanding
requests that may already be in the pipeline, which
may increase the estimated request horizon.
</P>
</DIV>
</DIV>

<P ALIGN="CENTER"><HR></P><P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ReturnS"> return value </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu_client__sync_timing.html"> prev </A>||<A HREF="kdu_client__tri$requests.html"> next </A>|</P>
</BODY>
</HTML>
