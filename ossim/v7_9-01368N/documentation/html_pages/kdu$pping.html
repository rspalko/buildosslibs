<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (kdu_channel_mapping) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#FFF491">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#FuncS"> functions </A>||<A HREF="#VarS"> variables </A>|</P>
<H1><A NAME="ToP">kdu_channel_mapping [struct]</A></H1>
<DIR><DIR><H3><U>Java:</U> class Kdu_channel_mapping</H3></DIR></DIR>

<P>[Declared in <A HREF="++++apps+s$decompressor+h.html">"../apps/support/kdu_region_decompressor.h"</A>]</P><P>[<U>c++ namespace</U> = "kdu_supp::"]</P>
<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
This object provides all information required to express
the relationship between code-stream image components
and the colour channels to be produced during rendering.
In the simplest case, each colour channel (red, green
and blue, or luminance) is directly assigned to a single
code-stream component. More generally, component samples
may need to be mapped through a pallete lookup table,
integer bit patterns might need to be reinterpreted
as custom floating point or fixed-point representations,
or a colour space transformation might be required.
</P><P>
 The purpose of this class is to capture the reproduction
functions required for correct colour reproduction,
so that they can be passed to the 
<A HREF="kdu$essor__start.html">kdu_region_decompressor::start</A> function.
</P><P>
 
<A HREF="kdu$pping.html">kdu_channel_mapping</A> objects also serve to capture any information concerning
opacity (alpha) channels.
</P><P>
 While it is possible to build the contents of the
object directly, in most cases you should use the 
<A HREF="kdu$pping__configure__1.html">configure</A> functions, selecting the particular overloaded version
of this function that accepts the highest level construct
available in your rendering task. For example, if your
rendering source is a JP2 or JPX file, you are recommended
to use the third form of the 
<A HREF="kdu$pping__configure__1.html">configure</A> function that directly accepts the key JP2-family
interfaces 
<A HREF="jp2_colour.html">jp2_colour</A>, 
<A HREF="jp2$nnels.html">jp2_channels</A> and so forth.
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="FuncS">Public Functions</A></H2><DIV CLASS="indented-text">
<P><A HREF="kdu$pping__kdu$l_mapping.html">kdu_channel_mapping</A> {<U>Java:</U> Kdu_channel_mapping}
</P>
<P><A HREF="kdu$pping__~kd$l_mapping.html">~kdu_channel_mapping</A> {<U>Java:</U> Native_destroy}
</P>
<P><A HREF="kdu$pping__clear.html">clear</A> {<U>Java:</U> Clear}
</P>
<P><A HREF="kdu$pping__configure__1.html">configure</A> <EM>(4 forms)</EM> {<U>Java:</U> Configure}
</P>
<P><A HREF="kdu$pping__add$iguration.html">add_alpha_to_configuration</A> {<U>Java:</U> Add_alpha_to_configuration}
</P>
<P><A HREF="kdu$pping__get$_channels.html">get_num_channels</A> {<U>Java:</U> Get_num_channels}
</P>
<P><A HREF="kdu$pping__set$_channels.html">set_num_channels</A> {<U>Java:</U> Set_num_channels}
</P>
<P><A HREF="kdu$pping__get$1_channels.html">get_num_colour_channels</A> {<U>Java:</U> Get_num_colour_channels}
</P>
<P><A HREF="kdu$pping__get$component.html">get_source_component</A> {<U>Java:</U> Get_source_component}
</P>
<P><A HREF="kdu$pping__get$precision.html">get_default_rendering_precision</A> {<U>Java:</U> Get_default_rendering_precision}
</P>
<P><A HREF="kdu$pping__get$ng_signed.html">get_default_rendering_signed</A> {<U>Java:</U> Get_default_rendering_signed}
</P>
<P><A HREF="kdu$pping__get$converter.html">get_colour_converter</A> {<U>Java:</U> Get_colour_converter}
</P>
</DIV>
<H2><A NAME="VarS">Public Variables</A></H2><DIV CLASS="indented-text">
<H4><A NAME="num_channels">num_channels</A> [<B>int</B>] -- <U>Exported Property</U>&nbsp;{ <A HREF="kdu$pping__get$_channels.html">get</A>; <A HREF="kdu$pping__set$_channels.html">set</A>; }</H4><DIV CLASS="indented-text">
<P>
Total number of channels to render, including colour
channels and opacity channels. The 
<A HREF="kdu$pping__configure__1.html">configure</A> function will set this member to the number of colour
channels (usually 1 or 3), adding one extra channel
if there is alpha (opacity) information. You can, however,
manually configure however many channels you like &mdash;
but you are recommended to do this only by explicitly
calling 
<A HREF="kdu$pping__set$_channels.html">set_num_channels</A>.
</P>
</DIV>
<H4><A NAME="num_colour_channels">num_colour_channels</A> [<B>int</B>] -- <U>Exported Property</U>&nbsp;{ <A HREF="kdu$pping__get$1_channels.html">get</A>; }</H4><DIV CLASS="indented-text">
<P>
Indicates the number of initial channels which are
used to describe pixel colour. This might be smaller
than 
<A HREF="kdu$pping.html#num_channels">num_channels</A> if, for example, opacity channels are to be rendered.
All channels are processed in the same way, except
in the event that colour space conversion is required.
</P>
</DIV>
<H4><A NAME="source_components">source_components</A> [<B>int</B>&nbsp;*]</H4><DIV CLASS="indented-text">
<P>
Array holding the indices of the codestream's output
image components which are used to form each of the
colour channels. There must be one entry for each channel,
although multiple channels may reference the same component.
Also, the mapping between source component samples
and channel sample values need not be direct.
</P><P>
 This array is allocated by 
<A HREF="kdu$pping__set$_channels.html">set_num_channels</A>, but the 
<A HREF="kdu$pping__configure__1.html">configure</A> functions do everything for you automatically.
</P>
</DIV>
<H4><A NAME="default_rendering_precision">default_rendering_precision</A> [<B>int</B>&nbsp;*]</H4><DIV CLASS="indented-text">
<P>
Indicates the default precision with which to represent
the sample values returned by the 
<A HREF="kdu$essor__process__1.html">kdu_region_decompressor::process</A> function in the event that it is invoked with a 
<B>precision_bits</B> argument of 0. A separate precision is provided for
each channel.
</P><P>
 If the value found in this array is zero, the corresponding
channel has no default precision, so the 
<A HREF="kdu$essor__process__1.html">kdu_region_decompressor::process</A> functions select the maximum precision offered by
the data type used to return sample values as the default
precision. This condition is introduced by the 
<A HREF="kdu$pping__configure__1.html">configure</A> functions only when dealing with JPX files whose 
<A HREF="jp2$nnels.html">jp2_channels</A> object reports a data format of 
<A HREF="globals.html#JP2_CHANNEL_FORMAT_FLOAT">JP2_CHANNEL_FORMAT_FLOAT</A>, so the original sample bit depth does not provide
any indication of intended precision for the rendered
content.
</P><P>
 If the 
<A HREF="kdu$pping__configure__1.html">configure</A> functions determine that the original representation
for a channel was to be interpreted as a fixed-point
P-bit integer with I integer bits and F=P-I fraction
bits, the 
<A HREF="kdu$pping.html#default_rendering_precision">default_rendering_precision</A> is set to F, rather than P. This is reasonable, since
F is the precision that remains after the fixed-point
number is scaled and clipped to the expected nominal
range. To recover the additional headroom associated
with a fixpoint-formatted channel or a float-formatted
channel, floating point versions of the 
<A HREF="kdu$essor__process__1.html">kdu_region_decompressor::process</A> function must be used.
</P><P>
 If any colour transformation is performed (see 
<A HREF="kdu$pping.html#colour_converter">colour_converter</A>), only the first entry of the 
<A HREF="kdu$pping.html#default_rendering_precision">default_rendering_precision</A> array is used &mdash; that is, all channels must have
the same default precision after colour conversion.
</P><P>
 This array is allocated by 
<A HREF="kdu$pping__set$_channels.html">set_num_channels</A>, but the 
<A HREF="kdu$pping__configure__1.html">configure</A> functions do everything automatically, setting the
entries up with the bit-depth values available from
the file format or code-stream headers, as appropriate.
Nonetheless, you can change the entries of this array
to suit the needs of your application.
</P>
</DIV>
<H4><A NAME="default_rendering_signed">default_rendering_signed</A> [<B>bool</B>&nbsp;*]</H4><DIV CLASS="indented-text">
<P>
Similar to 
<A HREF="kdu$pping.html#default_rendering_precision">default_rendering_precision</A>, but used to identify whether or not each channel's
samples should be rendered as signed quantities when
the 
<A HREF="kdu$essor__process__1.html">kdu_region_decompressor::process</A> function is invoked with a zero-valued 
<B>precision_bits</B> argument.
</P><P>
 If any colour transformation is performed (see 
<A HREF="kdu$pping.html#colour_converter">colour_converter</A>), this array is ignored; all transformed colour channels
default to an unsigned interpretation.
</P><P>
 Again, the array is allocated by 
<A HREF="kdu$pping__set$_channels.html">set_num_channels</A>. The 
<A HREF="kdu$pping__configure__1.html">configure</A> functions do everything automatically, setting the
entries up with values recovered from the file format
or code-stream headers, as appropriate, but you can
change the entries yourself if this turns out to be
appropriate to your application.
</P>
</DIV>
<H4><A NAME="channel_interp">channel_interp</A> [<A HREF ="kdu$nterp.html">kdu_channel_interp</A>&nbsp;*]</H4><DIV CLASS="indented-text">
<P>
Like all the other member arrays, this array provides
one entry per channel. It is allocated by 
<A HREF="kdu$pping__set$_channels.html">set_num_channels</A> and the entries can be manually configured if you
really know what you are doing, but this is strongly
discouraged. The 
<A HREF="kdu$pping__configure__1.html">configure</A> functions use this array's entries to record additional
details concerning the interpretation of the sample
values that are decompressed from the underlying codestream
and (if appropriate) subjected to any palette lookup
(see 
<B>palette</B>).
</P><P>
 The main reason for introducing this array is that
some channels might use sample values whose bit-patterns
(once expressed in the original integer representation
advertised by codestream headers and file boxes) actually
need to be re-interpreted as floating-point or fixed-point
bit patterns, rather than as integers. A second reason
for introducing the array is that it allows the capabilities
advdertised in connection with the 
<A HREF="kdu$essor__set$e_scaling.html">kdu_region_decompressor::set_true_scaling</A> function to be implemented in a way that does not
depend upon the 
<A HREF="kdu$pping.html#default_rendering_precision">default_rendering_precision</A> and 
<A HREF="kdu$pping.html#default_rendering_signed">default_rendering_signed</A> arrays retaining the values with which they were initialized
by 
<A HREF="kdu$pping__configure__1.html">configure</A> &mdash; they can be overridden by an application developer
to customize the behaviour of the 
<A HREF="kdu$essor__process__1.html">kdu_region_decompressor::process</A> functions, without losing track of the precise interpretation
of the decompressed sample values.
</P><P>
 The 
<A HREF="kdu$nterp.html#zeta">kdu_channel_interp::zeta</A> members affect the way in which 
<B>kdu_region_decompresor::process</B> maps decompressed and/or palette mapped values to
output samples, when the "true-zero" mode described
in connection with 
<A HREF="kdu$essor__set$e_scaling.html">kdu_region_decompressor::set_true_scaling</A> is in force. The 
<B>zeta</B> value is recovered by the 
<A HREF="kdu$pping__configure__1.html">configure</A> function from 
<A HREF="jp2_colour__get$ro_point.html">jp2_colour::get_natural_unsigned_zero_point</A>, where a 
<A HREF="jp2_colour.html">jp2_colour</A> interface is available. If a colour transform is performed,
however, (see 
<A HREF="kdu$pping.html#colour_converter">colour_converter</A>) the output samples are always mapped based on a natural
zero point of 
<B>zeta</B>=0.
</P><P>
 In order to emphasize the delicate nature of the information
in this array, we do not currently provide any accessors
to its content for non-native language bindings. Nonetheless,
the documentation provided for the 
<A HREF="kdu$nterp.html">kdu_channel_interp</A> object may prove instructive for those wanting to
gain a deep knowledge of what is going on.
</P>
</DIV>
<H4><A NAME="palette_bits">palette_bits</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
<P>
Number of index bits used with any palette lookup tables
found in the 
<B>palette</B> array. This value has no relationship to the precision
associated with the palette entries themselves.
</P>
</DIV>
<H4><A NAME="fix16_palette">fix16_palette</A> [<A HREF ="kdu$ple16.html">kdu_sample16</A>&nbsp;**]</H4><DIV CLASS="indented-text">
<P>
Array with 
<A HREF="kdu$pping.html#num_channels">num_channels</A> entries, each of which is either NULL or else a pointer
to a lookup table with 2^{
<A HREF="kdu$pping.html#palette_bits">palette_bits</A>} entries.
</P><P>
 Note carefully that each lookup table must have a
unique buffer, even if all lookup tables hold identical
contents. The buffer must be allocated using 
<B>new</B>, since it will automatically be de-allocated using
<B>delete</B> when the present object is destroyed, or its 
<A HREF="kdu$pping__clear.html">clear</A> function is called.
</P><P>
 If 
<A HREF="kdu$pping.html#palette_bits">palette_bits</A> is non-zero and one or more entries in the 
<B>palette</B> array are non-NULL, the corresponding colour channels
are recovered by scaling the relevant code-stream image
component samples (see 
<A HREF="kdu$pping.html#source_components">source_components</A>) to the range 0 through 2^{
<A HREF="kdu$pping.html#palette_bits">palette_bits</A>}-1 and applying them (as indices) to the relevant
lookup tables. If the code-stream image component has
an unsigned representation (this is common), the signed
samples recovered from 
<A HREF="kdu$1hesis.html">kdu_synthesis</A> or 
<A HREF="kdu$2coder.html">kdu_decoder</A> will be level adjusted to unsigned values before applying
them as indices to a palette lookup table.
</P><P>
 The entries in each 
<A HREF="kdu$pping.html#fix16_palette">fix16_palette</A> lookup table are 16-bit fixed point values, having
KDU_FIX_POINT fraction bits and representing normalized
quantities having the nominal range -0.5 to +0.5. The
<A HREF="kdu$pping.html#channel_interp">channel_interp</A> array provides additional information about the interpretation
of these palette entries, if they exist. In particular,
the original bit-depth of each palette entry and its
signed/unsigned nature can be learned from 
<B>kdu_channel_interp::orig_precision</B>, the true maximum value (as a normalized real-valued
quantity) and the true zero and natural zero points
can also be learned from 
<A HREF="kdu$nterp.html">kdu_channel_interp</A>.
</P><P>
 If a channel has a non-default data format, i.e. anything
other than 
<A HREF="globals.html#JP2_CHANNEL_FORMAT_DEFAULT">JP2_CHANNEL_FORMAT_DEFAULT</A>, the palette entries must be pre-converted, taking
exactly the same steps that are described in the documentation
of the 
<A HREF="jp2$lette__get_lut__1.html">jp2_palette::get_lut</A> functions or, equivalently, in the documentation of
the 
<A HREF="kdu$nterp.html">kdu_channel_interp</A> structure.
</P>
</DIV>
<H4><A NAME="float_palette">float_palette</A> [<B>float</B>&nbsp;**]</H4><DIV CLASS="indented-text">
<P>
Same as 
<A HREF="kdu$pping.html#fix16_palette">fix16_palette</A>, but the entries of these tables are all represented
at floating point precision. As with 
<A HREF="kdu$pping.html#fix16_palette">fix16_palette</A>, if the channel has a non-default data format (i.e.,
<A HREF="globals.html#JP2_CHANNEL_FORMAT_FLOAT">JP2_CHANNEL_FORMAT_FLOAT</A> or 
<A HREF="globals.html#JP2_CHANNEL_FORMAT_FIXPOINT">JP2_CHANNEL_FORMAT_FIXPOINT</A>), the palette entries must be pre-converted, taking
exactly the same steps that are described in the documentation
of the 
<A HREF="jp2$lette__get_lut__1.html">jp2_palette::get_lut</A> functions or, equivalently, in the documentation of
the 
<A HREF="kdu$nterp.html">kdu_channel_interp</A> structure.
</P><P>
 If a channel has a palette, it must have a non-NULL
<A HREF="kdu$pping.html#fix16_palette">fix16_palette</A> lookup table, but the corresponding 
<A HREF="kdu$pping.html#float_palette">float_palette</A> table is allowed to be NULL, except where a non-trivial
data format is involved. Specifically, the 
<A HREF="kdu$essor.html">kdu_region_decompressor</A> object expects both palette lookup tables to be available
at both precisions if channel uses a 
<B>KDU_CHANNEL_FORMAT_FLOAT</B> format or a 
<B>KDU_CHANNEL_FORMAT_FIXPOINT</B> format with a non-zero number of integer bits. Equivalently,
if the corresponding 
<A HREF="kdu$pping.html#channel_interp">channel_interp</A> entry has non-zero 
<A HREF="kdu$nterp.html#float_exp_bits">kdu_channel_interp::float_exp_bits</A> or 
<A HREF="kdu$nterp.html#fixpoint_int_bits">kdu_channel_interp::fixpoint_int_bits</A> entries, then either both or neither of the 
<A HREF="kdu$pping.html#fix16_palette">fix16_palette</A> and 
<A HREF="kdu$pping.html#float_palette">float_palette</A> entries for the channel should be non-NULL.
</P><P>
 In practice, the 
<A HREF="kdu$pping__configure__1.html">configure</A> function is almost always used to build these palette
lookup tables; it always installs tables with both
fix16 and float precision where there is a palette.
</P>
</DIV>
<H4><A NAME="colour_converter">colour_converter</A> [<A HREF ="jp2$erter.html">jp2_colour_converter</A>]</H4><DIV CLASS="indented-text">
<P>
Initialized to an empty interface (
<A HREF="jp2$erter__exists.html">colour_converter.exists</A> returns false), you may call 
<A HREF="jp2$erter__init.html">colour_converter.init</A> to provide colour transformation capabilities. This
object is used by reference within 
<A HREF="kdu$essor.html">kdu_region_decompressor</A>, so you should not alter its state while still engaged
in region processing.
</P><P>
 This object is initialized by the 2'nd and 3'rd forms
of the 
<A HREF="kdu$pping__configure__1.html">configure</A> function to convert the JP2 or JPX colour representation
to sRGB, if possible.
</P>
</DIV>
</DIV>
<P ALIGN="CENTER"><HR></P>
<P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#FuncS"> functions </A>||<A HREF="#VarS"> variables </A>|</P>
</BODY>
</HTML>
