<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (siz_params) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#FFF491">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#FuncS"> functions </A>|</P>
<H1><A NAME="ToP">siz_params</A></H1>
<DIR><DIR><H3><U>Java:</U> class Siz_params</H3></DIR></DIR>
<DIR><P>Derives from <A HREF ="kdu_params.html">kdu_params</A></P>
</DIR>
<P>[Declared in <A HREF="++++coresy$n+kdu_params+h.html">"../coresys/common/kdu_params.h"</A>]</P><P>[<U>c++ namespace</U> = "kdu_core::"]</P>
<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
Manages the information associated with a JPEG2000
<B>SIZ</B> marker segment. There is only one of these per image
&mdash; i.e., tile-specific and component-specific
forms of this parameter class (cluster type) are both
disallowed.
</P><P>
 The cluster name is "SIZ", but you are recommended
to use the macro 
<A HREF="globals.html#SIZ_params">SIZ_params</A>, in functions which take a cluster name like 
<A HREF="kdu_params__acc$_cluster__1.html">kdu_params::access_cluster</A>.
</P><P>
 This object also manages the information associated
with a JPEG2000 
<B>CBD</B> (Component Bit-Depth) marker segment, if any. There
is at most one of these per image, which must appear
in the main header. The CBD marker segment is written
if and only if the 
<A HREF="globals.html#Sextensions_MCT">Sextensions_MCT</A> flag is present in the 
<A HREF="globals.html#Sextensions">Sextensions</A> attribute managed by 
<A HREF="siz_params.html">siz_params</A>. The 
<B>CBD</B> marker segment is central to JPEG2000 Part-2 multi-component
transforms.
</P><P>
 This object also manages the information associated
with a JPEG2000 
<B>CAP</B> (Capabilities) marker segment, if any. There is at
most one of these per image, which must appear in the
main header. The CAP marker segment is written if 
<A HREF="globals.html#SCpart2_caps">SCpart2_caps</A> is non-zero; moreover, if the capability associated
with 
<A HREF="globals.html#SCpart2_caps">SCpart2_caps</A> is one that cannot be ignored by a decoder that does
not understand the associated ammendment capability,
the 
<A HREF="globals.html#Scap">Scap</A> boolean attribute is set to true when writing the
SIZ marker segment. During codestream parsing, the
<A HREF="globals.html#Scap">Scap</A> attribute determines what happens if a 
<B>CAP</B> marker segment is encountered that defines unrecognized
capabilities. If this happens and 
<A HREF="globals.html#Scap">Scap</A> is true, a warning message is generated; otherwise,
the unrecognized capabilities are silently ignored.
</P><P>
 The following attributes are defined. For an explanation
of pattern strings, consult the comments appearing
with 
<A HREF="kdu_params__par$e_string__1.html">kdu_params::parse_string</A>.
</P><UL><LI>
Macro = 
<A HREF="globals.html#Sprofile">Sprofile</A>; Pattern = "(PROFILE0=0,PROFILE1=1,PROFILE2=2,PART2=3,
CINEMA2K=4,CINEMA4K=5,BROADCAST=6,CINEMA2S=7,CINEMA4S=8,
CINEMASS=9,IMF=10)" &mdash; Restricted profile to which
the code-stream conforms. The value must currently
be an integer in the range 0 to 10. Profile0 is the
most restrictive profile for Part 1 conforming codestreams.
Profile2 places no restrictions on the code-stream
other than those restrictions imposed by ISO/IEC 15444-1
(JPEG2000, Part 1). A value of 3 means that the codestream
requires support for one or more features defined in
ISO/IEC 15444-2 (JPEG2000, Part 2) &mdash; additional
information about these extensions is identified via
the 
<A HREF="globals.html#Sextensions">Sextensions</A> parameter attribute. The values 4 and 5 correspond
to profile restrictions for Digital Cinema, while 6
identifies profile restrictions for broadcast applications.
Even though these have higher numerical values than
Part 2 codestreams, this is only for the purpose of
backward compatibility with earlier versions of Kakadu.
The 2K and 4K digital cinema profiles and the broadcast
profiles are closely relatred and very restrictive
subsets of JPEG2000 Part 1, defined by various ammendments
to the original standard. The values 7 and 8 correspond
to scalable versions of the 2K and 4K digital cinema
profiles, supporting 2 quality layers each, while value
9 identifies the "long term storage" digital cinema
profile, that supports dimensions up to 16384 x 8640
and 5 quality layers. The value 10 is used for the
IMF (Interoperable Master Format) profiles, which are
characterized by main- and sub-levels, reversibility
(or lack thereof) and three different maximum frame
sizes (2K, 4K and 8K). This auxiliary information is
provided via the 
<A HREF="globals.html#Simf">Simf</A> attribute. If the system determines that support for
Part 2 features is required, the profile will be set
automatically to 3. Also, if the 
<A HREF="globals.html#Sbroadcast">Sbroadcast</A> attribute is present, the profile is set automatically
to 6. Otherwise, the profile is not adjusted by Kakadu's
codestream creation machinery. However, if the profile
is found to be insufficient, the system will generate
a warning at the point where it first encounters an
inconsistency; this might not occur until near the
end of the processing in certain rare circumstances.
The system does perform some extensive checks for compliance
with the Digital Cinema profiles when they are used,
but only during codestream generation. It makes every
effort to set default values in such a way as to ensure
comliance with Digital Cinema profiles, where they
are used, but it is ultimately up to the user to supply
<A HREF="globals.html#Creslengths">Creslengths</A> (and possibly 
<A HREF="globals.html#Cagglengths">Cagglengths</A>) attributes so as to ensure that compressed data sizes
match the application-dependent constraints specified
by the Digital Cinema profile specifications. Similar
considerations apply to the broadcast profile, except
that it depends on additional information provided
via the 
<A HREF="globals.html#Sbroadcast">Sbroadcast</A> parameter attribute (similar to the connection between
the Part 2 profile and 
<A HREF="globals.html#Sextensions">Sextensions</A>). The default value for the 
<A HREF="globals.html#Sprofile">Sprofile</A> attribute is Profile2. When setting the profile, you
may find it convenient to use the macro's 
<A HREF="globals.html#Sprofile_PROFILE0">Sprofile_PROFILE0</A>, 
<A HREF="globals.html#Sprofile_PROFILE1">Sprofile_PROFILE1</A>, 
<A HREF="globals.html#Sprofile_PROFILE2">Sprofile_PROFILE2</A>, 
<A HREF="globals.html#Sprofile_CINEMA2K">Sprofile_CINEMA2K</A>, 
<A HREF="globals.html#Sprofile_CINEMA4K">Sprofile_CINEMA4K</A>, 
<A HREF="globals.html#Sprofile_BROADCAST">Sprofile_BROADCAST</A> and 
<A HREF="globals.html#Sprofile_PART2">Sprofile_PART2</A>.
</LI><LI>
Macro = 
<A HREF="globals.html#Sextensions">Sextensions</A>; Pattern = "[DC=1 | VARQ=2 | TCQ=4 | PRECQ=2048 |
VIS=8 | SSO=16 | DECOMP=32 | ANY_KNL=64 | SYM_KNL=128
| MCT=256 | NLT=512 | ROI=1024]" &mdash; Logical OR
of any combination of a number of flags, indicating
extended features from Part 2 of the JPEG2000 standard
which may be found in this codestream. When working
with the 
<A HREF="kdu_params__set__1.html">kdu_params::set</A> and 
<A HREF="kdu_params__get__1.html">kdu_params::get</A> functions, use the macros, 
<A HREF="globals.html#Sextensions_DC">Sextensions_DC</A>, 
<A HREF="globals.html#Sextensions_VARQ">Sextensions_VARQ</A>, 
<A HREF="globals.html#Sextensions_TCQ">Sextensions_TCQ</A>, 
<A HREF="globals.html#Sextensions_PRECQ">Sextensions_PRECQ</A>, 
<A HREF="globals.html#Sextensions_VIS">Sextensions_VIS</A>, 
<A HREF="globals.html#Sextensions_SSO">Sextensions_SSO</A>, 
<A HREF="globals.html#Sextensions_DECOMP">Sextensions_DECOMP</A>, 
<A HREF="globals.html#Sextensions_ANY_KNL">Sextensions_ANY_KNL</A>, 
<A HREF="globals.html#Sextensions_SYM_KNL">Sextensions_SYM_KNL</A>, 
<A HREF="globals.html#Sextensions_MCT">Sextensions_MCT</A>, 
<A HREF="globals.html#Sextensions_NLT">Sextensions_NLT</A> and 
<A HREF="globals.html#Sextensions_ROI">Sextensions_ROI</A>.
</LI><LI>
Macro = 
<A HREF="globals.html#Sbroadcast">Sbroadcast</A>; Pattern = "I(single=0,multi=1)(irrev=0,rev=1)" &mdash;
This parameter attribute provides more specific details
for the BROADCAST profile (
<A HREF="globals.html#Sprofile">Sprofile</A>=6). Its 3 fields have the following interpretation.
The first field identifies the broadcast profile level,
which is currently required to lie in the range 0 through
11. The profile level identifies the maximum bit-rate
(in Mbits/s meaning 10^6 bits/s) and sample-rate (in
Msamples/s meaning 10^6 samples/s) of a compressed
video stream, as described in Ammendment 4 to IS15444-1
and subsequently augmented by Ammendment 8 to IS15444-1.
Levels are as follows: 0 means unconstrained; 1 means
200Mbits/s,65Msamples/s; 2 means 200Mbits/s,130Msamples/s;
3 means 200Mbits/s,195Msamples/s; 4 means 400Mbits/s,260Msamples/s;
5 means 800Mbits/s,520Msamples/s; L &gt;= 6 means =
2^(L-6)*1600Mbits/s, 2^(L-6)*1200Msamples/s. The system
does not explicitly impose these constraints, since
they depend upon the intended frame rate &mdash; this
can readily be done at the application level. The second
field indicates whether the single-tile (0) or multi-tile
(1) variation of the profile is specified; the multi-tile
variation allows for either 1 or 4 tiles per image,
where multiple tiles must be identical in size and
involve either vertical tiles or 2 tiles in each direction.
When working with the 
<A HREF="kdu_params__set__1.html">kdu_params::set</A> and 
<A HREF="kdu_params__get__1.html">kdu_params::get</A> functions, use the macros 
<A HREF="globals.html#Sbroadcast_single">Sbroadcast_single</A> and 
<A HREF="globals.html#Sbroadcast_multi">Sbroadcast_multi</A> for this field's values. The third field indicates
whether the irreversible or reversible transform variation
of the profile is specified. When working with the
<B>kdu_parms::set</B> and 
<A HREF="kdu_params__get__1.html">kdu_params::get</A> functions, use the macros 
<A HREF="globals.html#Sbroadcast_irrev">Sbroadcast_irrev</A> and 
<A HREF="globals.html#Sbroadcast_rev">Sbroadcast_rev</A> for this field's values. During codestream generation,
this parameter attribute defaults to the single-tile,
irreversible level 1 variant if 
<A HREF="globals.html#Sprofile">Sprofile</A> equals 
<A HREF="globals.html#Sprofile_BROADCAST">Sprofile_BROADCAST</A>. Also, if 
<A HREF="globals.html#Sbroadcast">Sbroadcast</A> is specified and 
<A HREF="globals.html#Sprofile">Sprofile</A> is not explicitly specified, the system automatically
sets 
<A HREF="globals.html#Sprofile">Sprofile</A> to 
<A HREF="globals.html#Sprofile_BROADCAST">Sprofile_BROADCAST</A>.
</LI><LI>
Macro = 
<A HREF="globals.html#Simf">Simf</A>; Pattern = "II(irrev=0,rev=1)" &mdash; This parameter
attribute provides detailed profile constraints to
accompany the IMF (Interoperable Master Format) profile
(
<A HREF="globals.html#Sprofile">Sprofile</A>=10). Its three fields have the following interpretation.
The first field is the 
<B>main-level</B> of the profile, an integer in the range 0 to 11 that
describes the maximum number of samples per second,
taking into account frame rate, frame size and component
sub-sampling rate, as explained in Ammendment 8 of
IS15444-1: 0 means unspecified; 1 means 65Msamples/s;
2 means 130Msamples/s; 3 means 195Msamples/s; 4 means260Msamples/s;
5 means 520Msamples/s; and L &gt;= 6 means 2^(L-6)*1200Msamples/s.
Here 1 Msample/s means 10^6 samples/s. The second field
is the profile's sub-level, an integer in the range
0 to 9, which may not exceed the larger of 1 and the
main level minus 2; its purpose is to identify the
maximum bit-rate associated with the codestreams: 0
means unspecified; other values L mean 2^L * 10^8 bits/s.
The final field indicates whether the profile is irreversible
(
<A HREF="globals.html#Simf_irrev">Simf_irrev</A>) or reversible (
<A HREF="globals.html#Simf_rev">Simf_rev</A>), where the irreversible variant is required to be
untiled, while the reversible case allows for untiled
codestreams or tiled codestreams with tile dimensions
(
<A HREF="globals.html#Stiles">Stiles</A>) of 1024x1024, 2048x2048 or 4096x4096. During codestream
generation, if 
<A HREF="globals.html#Sprofile">Sprofile</A> equals 
<A HREF="globals.html#Sprofile_IMF">Sprofile_IMF</A>, this parameter attribute defaults to the main-level
0, sub-level 0, irreversible variant. Also, if 
<A HREF="globals.html#Simf">Simf</A> is specified and 
<A HREF="globals.html#Sprofile">Sprofile</A> is not explicitly specified, the system automatically
sets 
<A HREF="globals.html#Sprofile">Sprofile</A> to 
<A HREF="globals.html#Sprofile_IMF">Sprofile_IMF</A>.
</LI><LI>
Macro = 
<A HREF="globals.html#Scap">Scap</A>; Pattern = "B" &mdash; Flag indicating whether or
not capabilities defined in ammendments to the standards,
as recorded in the 
<B>CAP</B> marker segment, must be recognized for correct decoding
to occur. Currently, the only recognized capabilities
from ammendments are managed by the 
<A HREF="globals.html#SCpart2_caps">SCpart2_caps</A> attribute.
</LI><LI>
Macro = 
<A HREF="globals.html#SCpart2_caps">SCpart2_caps</A>; Pattern = "[EXTENDED_COD=32768]" &mdash; Identifies
capability extensions that are found in ammendments
to Part-2 of the JPEG2000 family of standards. Currently,
only one such capability, 
<A HREF="globals.html#SCpart2_caps_EXTENDED_COD">SCpart2_caps_EXTENDED_COD</A>, is defined, corresponding to the possible presence
of block-coder extensions in COD/COC marker segments.
This capability was introduced with IS15444-2/AMD4.
</LI><LI>
Macro = 
<A HREF="globals.html#Ssize">Ssize</A>; Pattern = "II" &mdash; Canvas dimensions: vertical
dimension first. For compressors, this will normally
be derived from the dimensions of the individual image
components. Explicitly supplying the canvas dimensions
may desirable if the source image files do not indicate
their dimensions, or if custom sub-sampling factors
are desired.
</LI><LI>
Macro = 
<A HREF="globals.html#Sorigin">Sorigin</A>; Pattern = "II" &mdash; Image origin on canvas: vertical
coordinate first. Defaults to {0,0}, or the tile origin
if one is given.
</LI><LI>
Macro = 
<A HREF="globals.html#Stiles">Stiles</A>; Pattern = "II" &mdash; Tile partition size: vertical
dimension first. Defaults to {0,0}.
</LI><LI>
Macro = 
<A HREF="globals.html#Stile_origin">Stile_origin</A>; Pattern = "II" &mdash; Tile origin on the canvas:
vertical coordinate first. Defaults to {0,0}].
</LI><LI>
Macro = 
<A HREF="globals.html#Scomponents">Scomponents</A>; Pattern = "I" &mdash; Number of codestream image
components. For compressors, this will normally be
deduced from the number and type of image files supplied
to the compressor. Note carefully, however, that if
a multi-component transform is used, the number of
codestream image components might not be equal to the
number of "output image components" given by 
<A HREF="globals.html#Mcomponents">Mcomponents</A>. In this case, the value of 
<A HREF="globals.html#Mcomponents">Mcomponents</A> and the corresponding 
<A HREF="globals.html#Mprecision">Mprecision</A> and 
<A HREF="globals.html#Msigned">Msigned</A> attributes should generally be associated with the
image files being read (for compression) or written
(for decompression).
</LI><LI>
Macro = 
<A HREF="globals.html#Ssigned">Ssigned</A>; Pattern = "B", [MULTI_RECORD, CAN_EXTRAPOLATE] &mdash;
Indicates whether each codestream image component contains
signed or unsigned sample values. Compression applications
that derive precision and signed/unsigned information
from input image files are recommended to explicitly
set 
<A HREF="globals.html#Nsigned">Nsigned</A> only, leaving the internal machinery to automatically
transfer 
<A HREF="globals.html#Nsigned">Nsigned</A> values to 
<A HREF="globals.html#Ssigned">Ssigned</A>, which happens whenever there is no Part-2 multi-component
transform (i.e., 
<A HREF="globals.html#Mcomponents">Mcomponents</A>=0). If there is a multi-component, 
<A HREF="globals.html#Nsigned">Nsigned</A> is usually sufficient to deduce 
<A HREF="globals.html#Msigned">Msigned</A> automatically, but you will need to explicitly specify
<A HREF="globals.html#Ssigned">Ssigned</A>. If any value for 
<A HREF="globals.html#Ssigned">Ssigned</A> is specified explicitly, all values must be specified
&mdash; missing values are derived by auto-replicating
the last value that was specified.
</LI><LI>
Macro = 
<A HREF="globals.html#Sprecision">Sprecision</A>; Pattern = "I", [MULTI_RECORD, CAN_EXTRAPOLATE] &mdash;
Indicates the bit-depth of each codestream image component.
Compression applications that derive precision and
signed/unsigned information from input image files
are recommended to explicitly set 
<A HREF="globals.html#Nprecision">Nprecision</A> only, leaving the values to be copied to 
<A HREF="globals.html#Sprecision">Sprecision</A> automatically. If there is a Part-2 multi-component
transform (
<A HREF="globals.html#Mcomponents">Mcomponents</A> != 0), however, 
<A HREF="globals.html#Nprecision">Nprecision</A> is usually sufficient to deduce 
<A HREF="globals.html#Mprecision">Mprecision</A> automatically, but you will need to explicitly specify
<A HREF="globals.html#Sprecision">Sprecision</A>. If any value for 
<A HREF="globals.html#Sprecision">Sprecision</A> is specified explicitly, all values must be specified
&mdash; missing values are derived by auto-replicating
the last value that was specified.
</LI><LI>
Macro = 
<A HREF="globals.html#Ssampling">Ssampling</A>; Pattern = "II", [MULTI_RECORD, CAN_EXTRAPOLATE] &mdash;
Indicates the sub-sampling factors for each codestream
image component. In each record, the vertical factor
appears first, followed by the horizontal sub-sampling
factor. The last supplied record is repeated indefinitely
for all remaining components. For compressors, a suitable
set of sub-sampling factors will normally be deduced
from the individual image component dimensions, expressed
via 
<A HREF="globals.html#Sdims">Sdims</A>.
</LI><LI>
Macro = 
<A HREF="globals.html#Sdims">Sdims</A>; Pattern = "II", [MULTI_RECORD, CAN_EXTRAPOLATE] &mdash;
Indicates the dimensions (vertical, then horizontal)
of each individual codestream image component. The
last supplied record is repeated indefinitely for all
remaining components. For compressors, the image component
dimensions will normally be deduced from the image
files supplied to the compressor, but may be explicitly
set if raw input files are to be used.
</LI><LI>
Macro = 
<A HREF="globals.html#Mcomponents">Mcomponents</A>; Pattern = "I" &mdash; Number of image components
produced at the output of the inverse multi-component
transform &mdash; during compression, you may think
of these as original image components. In any event,
we refer to them as "MCT output components", taking
the perspective of the decompressor. The value of 
<A HREF="globals.html#Mcomponents">Mcomponents</A> may be smaller than or larger than the 
<A HREF="globals.html#Scomponents">Scomponents</A> value, which refers to the number of "codestream image
components". During decompression, the codestream image
components are supplied to the input of the inverse
multi-component transform. Note carefully, however,
that for Kakadu to perform a forward multi-component
transform on image data supplied to a compressor, the
value of 
<A HREF="globals.html#Mcomponents">Mcomponents</A> must be at least as large as 
<A HREF="globals.html#Scomponents">Scomponents</A> and the inverse multi-component transform must provide
sufficient invertible transform blocks to derive the
codestream components from the output image components.
In the special case where 
<A HREF="globals.html#Mcomponents">Mcomponents</A> is 0, or not specified, there is no multi-component
transform. In this case, 
<A HREF="globals.html#Scomponents">Scomponents</A>, defines the number of output image components, but
<A HREF="globals.html#Scomponents">Scomponents</A> can be derived automatically from 
<A HREF="globals.html#Ncomponents">Ncomponents</A> if it has a non-zero value and 
<A HREF="globals.html#Mcomponents">Mcomponents</A>=0.
</LI><LI>
Macro = 
<A HREF="globals.html#Msigned">Msigned</A>; Pattern = "B", [MULTI_RECORD, CAN_EXTRAPOLATE] &mdash;
Indicates whether each MCT output component (see 
<A HREF="globals.html#Mcomponents">Mcomponents</A> for a definition of "MCT output components") contains
signed or unsigned sample values. Compressors that
obtain precision and signed/unsigned information from
input image files are recommended to use this information
to explicitly set 
<A HREF="globals.html#Nsigned">Nsigned</A>, leaving 
<A HREF="globals.html#Msigned">Msigned</A> to be deduced automatically (so long as 
<A HREF="globals.html#Mcomponents">Mcomponents</A> &gt; 0). The only condition under which 
<A HREF="globals.html#Msigned">Msigned</A> and 
<A HREF="globals.html#Nsigned">Nsigned</A> need to be explicitly specified separately is where
a non-linear point transform (see 
<A HREF="globals.html#NLType">NLType</A>) needs to change the signed characteristics of its
samples &mdash; probably not common. If you do specify
any 
<A HREF="globals.html#Msigned">Msigned</A> values, you need to supply them all, or be content
with the auto-replicating policy that replicates the
last specified value as required.
</LI><LI>
Macro = 
<A HREF="globals.html#Mprecision">Mprecision</A>; Pattern = "I", [MULTI_RECORD, CAN_EXTRAPOLATE] &mdash;
Indicates the bit-depth of each MCT output component
(see 
<A HREF="globals.html#Mcomponents">Mcomponents</A> for a definition of "MCT output components"). Compressors
that obtain precision and signed/unsigned information
from input image files are recommended to use this
information to explicitly set 
<A HREF="globals.html#Nprecision">Nprecision</A>, leaving 
<A HREF="globals.html#Mprecision">Mprecision</A> to be deduced automatically (so long as 
<A HREF="globals.html#Mcomponents">Mcomponents</A> &gt; 0). The only condition under which 
<A HREF="globals.html#Mprecision">Mprecision</A> and 
<A HREF="globals.html#Nprecision">Nprecision</A> need to be explicitly specified separately is where
a non-linear point transform (see 
<A HREF="globals.html#NLType">NLType</A>) needs to change the precision of its samples. If
you do specify any 
<A HREF="globals.html#Mprecision">Mprecision</A> values, you need to supply them all, or be content
with the auto-replicating policy that replicates the
last specified value as required.
</LI><LI>
Macro = 
<A HREF="globals.html#Ncomponents">Ncomponents</A>; Pattern = "I" &mdash; Number of image components
produced at the ultimate output of the decompression
process, after applying any required multi-component
transform and any non-linear point transforms that
may be defined. If 
<A HREF="globals.html#Mcomponents">Mcomponents</A> is non-zero (i.e., if there is a Part-2 multi-component
transform), 
<A HREF="globals.html#Ncomponents">Ncomponents</A> and 
<A HREF="globals.html#Mcomponents">Mcomponents</A> must be identical, so it is not strictly necessary
to explicitly specify 
<A HREF="globals.html#Ncomponents">Ncomponents</A> &mdash; it can be auto-deduced. If 
<A HREF="globals.html#Mcomponents">Mcomponents</A>=0, the values of 
<A HREF="globals.html#Ncomponents">Ncomponents</A> and 
<A HREF="globals.html#Scomponents">Scomponents</A> must be identical, so again it is not strictly necessary
to specify both.
</LI><LI>
Macro = 
<A HREF="globals.html#Nsigned">Nsigned</A>; Pattern = "B", [MULTI_RECORD, CAN_EXTRAPOLATE] &mdash;
Plays the same role as 
<A HREF="globals.html#Msigned">Msigned</A> and 
<A HREF="globals.html#Ssigned">Ssigned</A>, but describes the ultimate signed/unsigned attributes
of the samples produced during decompression after
applying any non-linear point transform. Compressors
are recommended to explicitly specify 
<A HREF="globals.html#Nsigned">Nsigned</A>, leaving the internal machinery to automatically deduce
<A HREF="globals.html#Msigned">Msigned</A> or 
<A HREF="globals.html#Ssigned">Ssigned</A> from 
<A HREF="globals.html#Nsigned">Nsigned</A> (by copying). If there is no Part-2 multi-component
transform, 
<A HREF="globals.html#Ssigned">Ssigned</A> will be copied from 
<A HREF="globals.html#Nsigned">Nsigned</A> or vice-versa if either is not specified. If there
is a Part-2 multi-component transform (i.e., 
<A HREF="globals.html#Mcomponents">Mcomponents</A> &gt; 0), 
<A HREF="globals.html#Msigned">Msigned</A> will be copied from 
<A HREF="globals.html#Nsigned">Nsigned</A> or vice-versa if either is not explicitly specified.
If you do specify any 
<A HREF="globals.html#Nsigned">Nsigned</A> attribute value, you must specify all 
<A HREF="globals.html#Ncomponents">Ncomponents</A> of them or be content with the auto-replicating policy
that replicates the last specified value as required.
</LI><LI>
Macro = 
<A HREF="globals.html#Nprecision">Nprecision</A>; Pattern = "I", [MULTI_RECORD, CAN_EXTRAPOLATE] &mdash;
Plays the same role as 
<A HREF="globals.html#Mprecision">Mprecision</A> and 
<A HREF="globals.html#Sprecision">Sprecision</A>, but describes the ultimate precision of the samples
produced during decompression after applying any non-linear
point transform. Compressors are recommended to explicitly
specify 
<A HREF="globals.html#Nprecision">Nprecision</A>, leaving the internal machinery to automatically deduce
<A HREF="globals.html#Mprecision">Mprecision</A> or 
<A HREF="globals.html#Sprecision">Sprecision</A> from 
<A HREF="globals.html#Nprecision">Nprecision</A> (by copying). If there is no Part-2 multi-component
transform, 
<A HREF="globals.html#Sprecision">Sprecision</A> will be copied from 
<A HREF="globals.html#Nprecision">Nprecision</A> or vice-versa if either is not specified. If there
is a Part-2 multi-component transform (i.e., 
<A HREF="globals.html#Mcomponents">Mcomponents</A> &gt; 0), 
<A HREF="globals.html#Mprecision">Mprecision</A> will be copied from 
<A HREF="globals.html#Nprecision">Nprecision</A> or vice-versa if either is not explicitly specified.
If you do specify any 
<A HREF="globals.html#Nprecision">Nprecision</A> attribute value, you must specify all 
<A HREF="globals.html#Ncomponents">Ncomponents</A> of them or be content with the auto-replicating policy
that replicates the last specified value as required.
</LI><LI>
Macro = 
<A HREF="globals.html#Scbr">Scbr</A>; Pattern="IF" &mdash; This attribute is currently
used only during content generation; it is not actually
recorded in any marker segment in the codestream. The
presence of an 
<A HREF="globals.html#Scbr">Scbr</A> attribute means that incremental flushing should be
performed, or at least simulated (all content can still
be flushed at the end) subject to a low latency objective.
The two parameters specify an integer flushing interval
V and the maximum size Bmax of a notional "leaky bucket"
that is inserted between the incremental flushing process
and a constant rate data channel. We now briefly explain
these concepts. The packet progression sequence for
each tile is required to be 
<A HREF="globals.html#Corder_PCRL">Corder_PCRL</A>, and there will usually only be one tile. No extra
tile-parts are currently allowed, so each tile (usually
just one) undergoes a series of flush operations that
are separated by V rows of lowest resolution precincts
from the lowest resolution of the first tile's first
codestream component. That is, each flush-set commences
with the first packet from precinct row V*k of the
lowest resolution in tile-component 0, where k=0,1,2,...
Normally, V will be 1, and precinct dimensions will
be chosen such that all flush sets involve the same
number of packets/precincts, except possibly the last
one. If image components have different sizes, you
will most likely need to adjust the number of vertical
decomposition levels and the precinct dimensions on
a per-component basis to ensure that all components
can flush the same number of precincts in each flush
set. The leaky bucket size Bmax is measured in terms
of lines from the first codestream image component.
Bmax need not be an integer, but it will be converted
internally to a leaky bucket size that is measured
in bytes. Bmax must be at least as large as the number
of lines from the first component in each flush-set.
Normally, Bmax should be larger than this, so as to
give the rate control algorithm some flexibility. The
overall target size L for the codestream, is converted
to a data rate D = L/T, where T is the total number
of samples in all subbands of the codestream. The gap
between one flush set and the next is considered to
be S, where S is the number of samples in the flush
set. Notice that we are measuring time in terms of
image samples, so the actual time gap between the flush
sets is S/Rsample, where Rsample is the image sample
data rate (samples/second), while the CBR channel has
a data rate of D*Rsample bytes/second. This inter-flush
separation model provides a valid mechanism for assessing
the delay attributed to communication, so long as all
flush sets (except possibly the last one) have the
same structure, so that flush sets naturally become
available at a constant rate from the compressor; an
informative error message is generated if this is not
the case. The maximum delay associated with the leaky
bucket model is then Bmax*Weff/Rsample seconds, where
Weff is an effective image width, being the width of
the first component multiplied by the ratio between
the total number of image samples and the number of
samples in the first component. The codestream main
header is included as part of the first flush set,
while the EOC marker is included as part of the last
flush set. Apart from this, the first flush set of
every tile includes that tile's tile-part header in
its byte count. According to the foregoing model, the
leaky bucket may not be filled beyond Bmax*Weff*D bytes
as a result of any given flush, after which S*D bytes
are drained from the bucket (S is the number of samples
in the flush) before the next flush. Accordingly, each
flush must fill the bucket to at least S*D bytes (to
avoid underflow) but to no more than Bmax*Weff*D bytes.
The last flush in the codestream is a little different;
it must fill the bucket to no more than S*D bytes,
so that the total number of bytes dumped into the bucket
by all flush operations does not exceed L, but it is
allowed to output fewer bytes; this is because we assume
that spacer bytes will be introduced between codestreams
in low latency CBR applications, so that each codestream
occupies exactly L bytes; there is then no need to
worry about buffer underflow or codestream indexing.
</LI></UL><P>
 Although the JPEG2000 
<B>SIZ</B> marker cannot represent negative coordinates, it is
particularly convenient to allow this object to store
and report negative coordinates. These should not trouble
applications which interface with it, since all of
the algebraic properties of the coordinate system still
hold. Negative coordinates will be converted into appropriate
non-negative coordinates only when a valid marker segment
must be written out &mdash; to do this the 
<B>write_marker_segment</B> function must examine various 
<A HREF="cod_params.html">cod_params</A> attributes from every tile-component in the image
to determine appropriate offsets to the negative coordinates
which will not alter the interpretation of the canvas
coordinate system.
</P><P>
 For the above reason, you should avoid writing a 
<B>SIZ</B> marker segment (calling 
<A HREF="kdu_params__gen$segments.html">kdu_params::generate_marker_segments</A>) until all code-stream parameters have been finalized
for all tiles and tile-components.
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="FuncS">Public Functions</A></H2><DIV CLASS="indented-text">
<P><A HREF="siz_params__siz_params.html">siz_params</A> {<U>Java:</U> Siz_params}
</P>
<P><A HREF="siz_params__~siz_params.html">~siz_params</A> [virtual] {<U>Java:</U> Native_destroy}
</P>
</DIV>
<P ALIGN="CENTER"><HR></P>
<P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#FuncS"> functions </A>|</P>
</BODY>
</HTML>
