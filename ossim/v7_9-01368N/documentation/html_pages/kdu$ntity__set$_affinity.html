<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (kdu_thread_entity::set_cpu_affinity) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
.function-text { padding-left: 80pt;
                 text-indent: -60pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#B4DCB4">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ReturnS"> return value </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$ntity__destroy.html"> prev </A>||<A HREF="kdu$ntity__set$ncurrency.html"> next </A>|</P>
<H1><A NAME="ToP">kdu_thread_entity::set_cpu_affinity</A></H1>
<DIR><DIR><H3><EM><U>Java:</U> Kdu_thread_entity.Set_cpu_affinity</EM></H3></DIR></DIR>
<P CLASS="function-text"><B>bool</B> set_cpu_affinity(
const&nbsp;<A HREF ="kdu$inity.html">kdu_thread_entity_affinity</A>&nbsp;&amp;&nbsp;affinity)</P>
<DIR><DIR><P CLASS="function-text"><EM><U>Java:</U> public native boolean Set_cpu_affinity(
Kdu_thread_entity_affinity&nbsp;affinity)</EM></P></DIR></DIR>
<P><A HREF="kdu$ntity.html">Go to class description.</A></P>

<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
This function plays an important role on NUMA (non-uniform
machine architecture) platforms. On Windows platforms,
at least, the function is also critical to unlocking
the resources of more than 64 logical CPUs (or, in
general, the resources of more than a single processor
group).
</P><P>
 For the purposes of this function, the threads in
a thread group are numbered from 0 to T, where T is
the number of successful calls to 
<A HREF="kdu$ntity__add_thread.html">add_thread</A>, thread 0 is the group owner, and thread t is the
worker thread added via the t'th call to 
<A HREF="kdu$ntity__add_thread.html">add_thread</A>. These threads are collected into bundles b=0,1,...,
with Tb threads in bundle b, such that threads 0 to
T0-1 belong to bundle 0, threads T0 to T0+T1-1 belong
to bundle 1, and so forth. All threads in a bundle
are assigned the same CPU affinity, but different bundles
may have different affinities, as captured by calls
to the 
<A HREF="kdu$inity__add$ad_bundle.html">affinity.add_thread_bundle</A> function.
</P><P>
 It is worth noting that no thread may be assigned
affinity with any more than 64 different logical CPUs,
as explained in connection with the 
<A HREF="kdu_thread__set$affinity.html">kdu_thread::set_cpu_affinity</A> function. This means that the only way to leverage
all resources of a platform with more than 64 CPUs
is to set up multiple thread bundles and pass the configured
<A HREF="kdu$ntity__set$_affinity.html#affinity">affinity</A> object to this function. Nonetheless, the number of
worker threads that can be added to this object may
never exceed 
<B>KDU_MAX_THREADS</B>-1.
</P><P>
 Bundles also allow you to bind logical CPUs to thread
domains, since calls to 
<A HREF="kdu$ntity__add_thread.html">add_thread</A> may associate each worker thread with a specific named
domain, and this function associates specific bundles
of threads with logical CPUs. Thread queues are associated
with domains, and those jobs that are scheduled to
a queue are serviced preferentially by threads belonging
to the queue's domain. So, for example, you could choose
to add some worker threads to the 
<A HREF="globals.html#KDU_TRANSFORM_THREAD_DOMAIN">KDU_TRANSFORM_THREAD_DOMAIN</A> that is defined by 
<A HREF="kdu$1lysis.html">kdu_multi_analysis</A> and 
<A HREF="kdu$hesis.html">kdu_multi_synthesis</A>, and arrange for those thread numbers belong to a
specific bundle, allowing you to assign the preferred
CPU affinity for DWT analysis and synthesis processing.
This might be a good idea in a hyperthreading environment
if DWT processing were the bottlneck for a workload,
since it can allow you to minimize the risk that DWT
processing jobs share a physical CPU with any other
jobs.
</P><P>
 You should call this function immediately after 
<A HREF="kdu$ntity__create.html">create</A>, before any calls to 
<A HREF="kdu$ntity__add_thread.html">add_thread</A> so that the relevant affinity can be assigned to worker
threads as they are created. The function does nothing
unless invoked by the group owner thread &mdash; i.e.,
the thread that called 
<A HREF="kdu$ntity__create.html">create</A> or the thread that most recently called 
<A HREF="kdu$ntity__cha$er_thread.html">change_group_owner_thread</A>.
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="ReturnS">Return Value</A></H2><DIV CLASS="indented-text">
<P>
True if the 
<A HREF="kdu$ntity__create.html">create</A> function has been successfully called so that there
is a thread group associated with this object AND the
function is being invoked by the group owner thread.
Otherwise, the function returns false, doing nothing.
</P>
</DIV>
<H2><A NAME="ArgS">Arguments</A></H2><DIV CLASS="indented-text">
<H4><A NAME="affinity">affinity</A> [const&nbsp;<A HREF ="kdu$inity.html">kdu_thread_entity_affinity</A>&nbsp;&amp;]</H4><DIV CLASS="indented-text">
</DIV>
</DIV>

<P ALIGN="CENTER"><HR></P><P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ReturnS"> return value </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$ntity__destroy.html"> prev </A>||<A HREF="kdu$ntity__set$ncurrency.html"> next </A>|</P>
</BODY>
</HTML>
