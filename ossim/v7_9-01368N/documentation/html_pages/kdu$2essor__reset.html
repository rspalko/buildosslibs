<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (kdu_stripe_decompressor::reset) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
.function-text { padding-left: 80pt;
                 text-indent: -60pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#B4DCB4">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$2essor__finish.html"> prev </A>||<A HREF="kdu$2essor__get$_heights.html"> next </A>|</P>
<H1><A NAME="ToP">kdu_stripe_decompressor::reset</A></H1>
<DIR><DIR><H3><EM><U>Java:</U> Kdu_stripe_decompressor.Reset</EM></H3></DIR></DIR>
<P CLASS="function-text"><B>void</B> reset(
<B>bool</B>&nbsp;free_memory=true)</P>
<DIR><DIR><P CLASS="function-text"><EM><U>Java:</U> public native void Reset(
boolean&nbsp;free_memory)</EM></P></DIR></DIR>
<P><A HREF="kdu$2essor.html">Go to class description.</A></P>

<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
Each call to 
<A HREF="kdu$2essor__start.html">start</A> must be bracketed by a call to either 
<A HREF="kdu$2essor__finish.html">finish</A> or 
<A HREF="kdu$2essor__reset.html">reset</A>, although the destructor itself invokes 
<A HREF="kdu$2essor__reset.html">reset</A>. Like 
<A HREF="kdu$2essor__finish.html">finish</A>, this function does nothing if the object has already
been finished or reset. The main differences between
this function and 
<A HREF="kdu$2essor__reset.html">reset</A> are:
</P><UL><LI>
This function completely ignores any 
<A HREF="kdu$d_env.html">kdu_thread_env</A> reference that may have been passed to 
<A HREF="kdu$2essor__start.html">start</A>, assuming that the multi-threaded environment has
either been destroyed, or at least all multi-threaded
work related to this object has and the 
<B>codestream</B> passed to 
<A HREF="kdu$2essor__start.html">start</A> has been terminated.
</LI><LI>
The above property means that you must call this function
instead of 
<A HREF="kdu$2essor__finish.html">finish</A> if a non-NULL 
<A HREF="kdu$d_env.html">kdu_thread_env</A> reference was passed to 
<A HREF="kdu$2essor__start.html">start</A> but the multi-threaded environment has since been
destroyed (e.g., during exception handling).
</LI><LI>
Unlike 
<A HREF="kdu$2essor__finish.html">finish</A>, this function de-allocates all memory resources,
unless you pass false in the 
<A HREF="kdu$2essor__reset.html#free_memory">free_memory</A> argument.
</LI></UL><P>
 If you did pass a non-NULL 
<B>env</B> argument to 
<A HREF="kdu$2essor__start.html">start</A> and you call this function in place of 
<A HREF="kdu$2essor__finish.html">finish</A>, you need to keep the following in mind:
</P><UL><LI>
You must be sure that there is no multi-threaded processing
going on when this call arrives. One way to ensure
this is to destroy the multi-threaded processing environment.
Another way is to invoke 
<B>kdu_thread_queue::terminate</B> or 
<B>kdu_thread_queue::join</B> (not so interesting for abortive processing) on a
non-NULL 
<B>env_queue</B> that was passed to 
<A HREF="kdu$2essor__start.html">start</A>.
</LI><LI>
If the multi-threaded processing environment is not
destroyed, you should also note that the 
<A HREF="kdu$d_env__cs_terminate.html">kdu_thread_env::cs_terminate</A> function needs to be explicitly called first, before
invoking this function!!!
</LI></UL><P>
 You should be sure to call this function or 
<A HREF="kdu$2essor__finish.html">finish</A> before destroying the 
<A HREF="kdu$tream.html">kdu_codestream</A> interface that was passed to 
<A HREF="kdu$2essor__start.html">start</A>.
</P><P>
 In summary, if you have a live multi-threaded environment
still running, you must do things in the following
order:
</P><UL><LI>
Terminate or join on 
<B>env_queue</B> passed to 
<A HREF="kdu$2essor__start.html">start</A>.
</LI><LI>
<A HREF="kdu$d_env__cs_terminate.html">kdu_thread_env::cs_terminate</A> the codestream passed to 
<A HREF="kdu$2essor__start.html">start</A></LI><LI>
Call this 
<A HREF="kdu$2essor__reset.html">reset</A> function
</LI><LI>
<A HREF="kdu$tream__destroy.html">kdu_codestream::destroy</A> &mdash; can happen any time.
</LI></UL>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="ArgS">Arguments</A></H2><DIV CLASS="indented-text">
<H4><A NAME="free_memory">free_memory</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
<P>
Normally, calls to 
<A HREF="kdu$2essor__reset.html">reset</A> should deallocate all internal memory resources; however,
if you wish to retain the memory, so that it can be
used again after a subsequent call to 
<A HREF="kdu$2essor__start.html">start</A>, this can be arranged by passing false for the 
<A HREF="kdu$2essor__reset.html#free_memory">free_memory</A> argument. This might be appropriate if an exception
occurred, causing you to destroy a multi-threaded processing
environment and invoke 
<A HREF="kdu$2essor__reset.html">reset</A>, but you wish to reconstruct the multi-threaded processing
environment and re-enter the 
<A HREF="kdu$2essor__start.html">start</A> function without having to re-allocate all resources.
</P>
</DIV>
</DIV>

<P ALIGN="CENTER"><HR></P><P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$2essor__finish.html"> prev </A>||<A HREF="kdu$2essor__get$_heights.html"> next </A>|</P>
</BODY>
</HTML>
