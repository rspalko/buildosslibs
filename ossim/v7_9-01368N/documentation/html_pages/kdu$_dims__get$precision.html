<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (kdu_image_dims::get_forced_precision) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
.function-text { padding-left: 80pt;
                 text-indent: -60pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#B4DCB4">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$_dims__set$precision.html"> prev </A>|</P>
<H1><A NAME="ToP">kdu_image_dims::get_forced_precision</A></H1>
<P CLASS="function-text"><B>int</B> get_forced_precision(
<B>int</B>&nbsp;comp_idx,
<B>bool</B>&nbsp;&amp;&nbsp;align_lsbs,
<B>int</B>&nbsp;&amp;&nbsp;exponent_bits)</P>
<P><A HREF="kdu$_dims.html">Go to class description.</A></P>

<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
This function returns 0 if no forced precision information
is available (i.e., 
<A HREF="kdu$_dims__set$precision.html">set_forced_precision</A> has not been called, or it has been called with a
precision value of 0). Positive values P returned by
the function identify a forced precision for the component,
whose meaning is explained below. A negative value
(only -1) may also be returned, in which case the precision
itself is not being forced but the 
<A HREF="kdu$_dims__get$precision.html#exponent_bits">exponent_bits</A> argument is still relevant, as explained below.
</P><P>
 If no call to 
<A HREF="kdu$_dims__set$precision.html">set_forced_precision</A> has occurred for 
<A HREF="kdu$_dims__get$precision.html#comp_idx">comp_idx</A>, the function replicates any information that may
have been supplied for the closest component c &lt;
<A HREF="kdu$_dims__get$precision.html#comp_idx">comp_idx</A>.
</P><P>
 If an image file reader supports precision forcing,
it should interpret a positive value returned by this
function as the bit-depth of the sample values which
should be supplied in response to a call to 
<A HREF="kdu$ge_in__get.html">kdu_image_in::get</A>. When the image reader is initialized, it may use
the value returned by 
<A HREF="kdu$_dims__get$bit_depth.html">get_bit_depth</A> if required, to determine the precision of the data
samples recorded in the file (this is only needed for
raw files). However, it should explicitly change this
value (via 
<A HREF="kdu$_dims__set$bit_depth.html">set_bit_depth</A>) to the forced precision. Negative return values from
this function mean that the image file reader should
select the most natural precision to employ, which
means that there is no precision forcing, except that
positive values of 
<A HREF="kdu$_dims__get$precision.html#exponent_bits">exponent_bits</A> still impact the way in which sample values are processed,
as described below.
</P><P>
 The precision forcing algorithm depends on the values
returned via 
<A HREF="kdu$_dims__get$precision.html#align_lsbs">align_lsbs</A> and 
<A HREF="kdu$_dims__get$precision.html#exponent_bits">exponent_bits</A>, with the following interpretation for image file
readers:
</P><UL><LI>
If 
<A HREF="kdu$_dims__get$precision.html#exponent_bits">exponent_bits</A> = 0 and 
<A HREF="kdu$_dims__get$precision.html#align_lsbs">align_lsbs</A> is true, the sample values read from the image file
are forced to fit into the identified precision as
integers, without any scaling. This means that a value
of 1 in the original file will remain 1 after precision
forcing. Values which exceed the range which can be
represented by the forced precision should be clipped
&mdash; as opposed to just ignoring the most significant
bits.
</LI><LI>
If 
<A HREF="kdu$_dims__get$precision.html#exponent_bits">exponent_bits</A> = 0 and 
<A HREF="kdu$_dims__get$precision.html#align_lsbs">align_lsbs</A> is false, the sample values read from the image file
are converted to integers (if necessary) and scaled
by a power of 2, such that the most significant bit
in the original representation corresponds to the most
significant bit in the representation produced by precision
forcing. If this involves the synthesis of additional
LSB's, they should be set to 0; if it involves the
elimination of original LSB's, rounding to the nearest
representable value should be employed.
</LI><LI>
If 
<A HREF="kdu$_dims__get$precision.html#exponent_bits">exponent_bits</A> &gt; 0, the 
<A HREF="kdu$_dims__get$precision.html#align_lsbs">align_lsbs</A> value is irrelevant, but will be false. Values read
from the image file are converted to a floating point
format which involves a leading sign bit, E exponent
bits and then M mantissa bits, where M = P-E-1, P is
the precision returned by the function and E is the
<A HREF="kdu$_dims__get$precision.html#exponent_bits">exponent_bits</A> value. If the function returns a negative value (-1
in practice), the image reader is free to select a
suitable value for P, which may be useful. For example,
if the source image already contains floating point
sample values, P would most naturally be set to 32.
In any case, P must be selected no smaller than E+1.
If the function's positive return value is smaller
than E+1, an error should be generated. The E-bit exponent
is a signed quantity that has been offset by 2^{E-1}-1
to yield unsigned E-bit values for the floating point
representation &mdash; this is the common convention
for IEEE and other floating point standards. After
conversion to this representation, the P-bit quantities
are re-interpreted as integers which are returned via
calls to 
<A HREF="kdu$ge_in__get.html">kdu_image_in::get</A>. This mapping of floats to integers is intended to
work in tandem with Part-2 non-linear point transforms
(NLT) of the 
<A HREF="globals.html#NLType_SMAG">NLType_SMAG</A> and 
<A HREF="globals.html#NLType_UMAG">NLType_UMAG</A> types, in which the floating-point bit patterns are
transformed in a manner which renders them suitable
for efficient compression. The floating point representation
should be described via a "Pixel Format" box within
any relevant compositing layers of a JPX output file
that contains imagery compressed in this way. If 
<A HREF="kdu$_dims__get$precision.html#exponent_bits">exponent_bits</A> &gt; 0, raw input images are assumed to contain floating
point values with exactly the same number of exponent
bits, but perhaps a different number of mantissa bits,
since the original precision found by calling 
<A HREF="kdu$_dims__get$bit_depth.html">get_bit_depth</A> may differ from that returned by this function. For
components that are identified as unsigned (see 
<A HREF="kdu$_dims__get_signed.html">get_signed</A>), floating point representations are assumed to have
a 0 in the sign bit position, and may need to be truncated
to such a state. Where samples need to be converted
from N-bit integers to the P-bit floating point representation
with E-bit exponent, the conversion maps unsigned integers
in the range 0 to 2^N-1 to floats in the range 0.0
to 1.0, while signed integers in the range -2^{N-1}
to 2^{N-1}-1 are mapped to floats in the range -1.0-2^{1-N}
to 1.0. This conversion is most compatible with the
way in which JPX files interpret different pixel formats
and colour spaces.
</LI></UL><P>
 If an image file writer supports precision forcing,
it should interpret a positive value returned by this
function as the bit-depth of the samples to be recorded
in the output file. In this case, the value returned
by 
<A HREF="kdu$_dims__get$bit_depth.html">get_bit_depth</A> represents the actual precision of the data supplied
via the 
<A HREF="kdu$e_out__put.html">kdu_image_out::put</A> function. Again, the behaviour of the file writer
depends upon the 
<A HREF="kdu$_dims__get$precision.html#align_lsbs">align_lsbs</A> and 
<A HREF="kdu$_dims__get$precision.html#exponent_bits">exponent_bits</A> values, and a negative return value has meaning when
accompanied by a non-zero 
<A HREF="kdu$_dims__get$precision.html#exponent_bits">exponent_bits</A> value, as explained below:
</P><UL><LI>
If 
<A HREF="kdu$_dims__get$precision.html#exponent_bits">exponent_bits</A> = 0 and 
<A HREF="kdu$_dims__get$precision.html#align_lsbs">align_lsbs</A> is true, the sample values written to the output file
as integers are not scaled, meaning that a value of
1 (with respect to the 
<A HREF="kdu$_dims__get$bit_depth.html">get_bit_depth</A> precision) should be written as a 1 (with respect
to the forced precision used in the output file). If
the 
<A HREF="kdu$_dims__get$bit_depth.html">get_bit_depth</A> value is larger than the forced precision, some values
may need to be clipped to the range which can be accommodated
by the 
<B>forced_precision</B>.
</LI><LI>
If 
<A HREF="kdu$_dims__get$precision.html#exponent_bits">exponent_bits</A> = 0 and 
<A HREF="kdu$_dims__get$precision.html#align_lsbs">align_lsbs</A> is false, the sample values written to the output
file as integers are scaled, so that the most significant
bit of the representation used to supply data via 
<A HREF="kdu$e_out__put.html">kdu_image_out::put</A> is aligned with the most significant bit of the forced
precision used to actually write the data. Such scaling
is always by a power of 2; rounding to the nearest
representable value should be employed if LSB's are
discarded during the shifting process.
</LI><LI>
If 
<A HREF="kdu$_dims__get$precision.html#exponent_bits">exponent_bits</A> &gt; 0, the 
<A HREF="kdu$_dims__get$precision.html#align_lsbs">align_lsbs</A> value is irrelevant but will be false. Values supplied
as absolute integers via 
<A HREF="kdu$e_out__put.html">kdu_image_out::put</A> have their bit-patterns re-interpreted a floating
point values with 1 sign bit, followed by E exponent
bits and then N-1-E mantissa bits, following all the
same conventions as described above for image readers,
where N is the incoming bit-depth returned by 
<A HREF="kdu$_dims__get$bit_depth.html">get_bit_depth</A>. For raw output files, these values are written as
P-bit floating point values with the same number of
exponent bits E, but P-1-E mantissa bits, where P is
the forced precision value returned by this function.
For output file formats that can explicitly accommodate
the writing of P-bit floating point data, the source
values are converted (if necessary) to accommodate
any differences in the number of exponent bits &mdash;
i.e., the E=
<A HREF="kdu$_dims__get$precision.html#exponent_bits">exponent_bits</A> value describes the input samples, not necessarily
the output samples. Otherwise, the floating point values
are converted to a signed or unsigned P-bit integer
representation, depending on the value returned by
<A HREF="kdu$_dims__get_signed.html">get_signed</A>. In this latter case, the conversion to unsigned integers
is such that floats in the range 0.0 to 1.0 map to
integers in the range 0 to 2^P-1; the conversion to
signed integers is such that floats are scaled by 2^{P-1}-1,
and clipped to the range -2^{P-1} to 2^{P-1}-1, which
roughly accommodates floats in the range -1.0 to 1.0.
If the function returns a negative value (-1 in practice),
the image writer is free to select the most appropriate
precision for its written samples, but all the other
implications of a non-zero 
<A HREF="kdu$_dims__get$precision.html#exponent_bits">exponent_bits</A> field remain. This can be especially useful, since
it allows the writer to be informed of the floating
point nature of the data that it will be passed, while
giving the writer an opportunity to determine how best
to represent the samples.
</LI></UL>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="ArgS">Arguments</A></H2><DIV CLASS="indented-text">
<H4><A NAME="comp_idx">comp_idx</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
</DIV>
<H4><A NAME="align_lsbs">align_lsbs</A> [<B>bool</B>&nbsp;&amp;]</H4><DIV CLASS="indented-text">
</DIV>
<H4><A NAME="exponent_bits">exponent_bits</A> [<B>int</B>&nbsp;&amp;]</H4><DIV CLASS="indented-text">
</DIV>
</DIV>

<P ALIGN="CENTER"><HR></P><P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$_dims__set$precision.html"> prev </A>|</P>
</BODY>
</HTML>
