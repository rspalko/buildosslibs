<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (kdu_subband::open_block) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
.function-text { padding-left: 80pt;
                 text-indent: -60pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#B4DCB4">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$bband__det$_notifier.html"> prev </A>||<A HREF="kdu$bband__close_block.html"> next </A>|</P>
<H1><A NAME="ToP">kdu_subband::open_block</A></H1>
<DIR><DIR><H3><EM><U>Java:</U> Kdu_subband.Open_block</EM></H3></DIR></DIR>
<P CLASS="function-text"><A HREF ="kdu_block.html">kdu_block</A>&nbsp;* open_block(
<A HREF ="kdu_coords.html">kdu_coords</A>&nbsp;block_idx,
<B>int</B>&nbsp;*&nbsp;return_tpart=NULL,
<A HREF ="kdu$d_env.html">kdu_thread_env</A>&nbsp;*&nbsp;env=NULL,
<B>int</B>&nbsp;hscan_length=0,
<B>bool</B>&nbsp;hscan_start=false)</P>
<DIR><DIR><P CLASS="function-text"><EM><U>Java:</U> public native Kdu_block Open_block(
Kdu_coords&nbsp;block_idx,
int[]&nbsp;return_tpart,
Kdu_thread_env&nbsp;env,
int&nbsp;hscan_length,
boolean&nbsp;hscan_start)</EM></P></DIR></DIR>
<P><A HREF="kdu$bband.html">Go to class description.</A></P>

<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
Code-block access is bracketed by calls to 
<A HREF="kdu$bband__open_block.html">open_block</A> and 
<A HREF="kdu$bband__close_block.html">close_block</A>. It is currently illegal to have more than one code-block
open per-thread at the same time. In fact, the underlying
structure manages storage for a single 
<A HREF="kdu_block.html">kdu_block</A> object, in the main 
<A HREF="kdu$tream.html">kdu_codestream</A> machinery, and one for each thread within a 
<A HREF="kdu$d_env.html">kdu_thread_env</A> environment.
</P><P>
 It is also illegal to open any given block a second
time without first closing the tile (input codestreams)
or the relevant precinct (interchange codestreams)
and re-opening it. Moreover, such activities are permitted
only with interchange codestreams or input codestreams
which have been set up for persistence by calling the
<A HREF="kdu$tream__set$ersistent.html">kdu_codestream::set_persistent</A> function.
</P><P>
 This restriction on multiple openings of any given
code-block is important for the efficiency of the system,
since it allows the internal machinery to determine
when resources can be destroyed, recycled or temporarily
swapped out of memory. Applications which do wish to
open blocks multiple times will generally be happy
to close and re-open the tile (or precinct) anyway.
</P><P>
 The returned 
<A HREF="kdu_block.html">kdu_block</A> object contains all necessary information for encoding
or decoding the code-block, including its dimensions,
coding mode switches and so forth.
</P><P>
 For input codestreams (created using the particular
form of the overloaded 
<A HREF="kdu$tream__create__1.html">kdu_codestream::create</A> function which takes a compressed data source), the
block will have all coding pass and code-byte information
intact, ready to be decoded. Moreover, the function
arranges for 
<A HREF="kdu_block.html#byte_buffer">kdu_block::byte_buffer</A> to be large enough to allow access to at least one
aligned 32-bit word beyond the last actual code byte
within 
<A HREF="kdu_block.html#byte_buffer">kdu_block::byte_buffer</A>, allowing the caller to implement efficient buffer
parsing and end-of-buffer detection algorithms, based
on marker codes with various structures.
</P><P>
 Otherwise (output or interchange codestreams), all
relevant members of the returned 
<A HREF="kdu_block.html">kdu_block</A> object will be initialized to the empty state, ready
to accept newly generated (or copied) code bytes.
</P><P>
 It is worth noting that opening a block may have far
reaching implications for the internal code-stream
management machinery. Precincts may be created for
the first time; packets may be read and de-sequenced;
tile-parts may be opened and so forth. There is no
restriction on the order in which code-blocks may be
opened, although different orders can have very different
implications for the amount of the code-stream which
must be buffered internally, especially if the compressed
data source does not support seeking, or the code-stream
does not provide seeking hints (these are optional
JPEG2000 marker segments).
</P><P>
 Although this function may be used with interchange
codestreams, its namesake in the 
<A HREF="kdu$cinct.html">kdu_precinct</A> interface is recommended instead for interchange applications.
For more on this, consult the comments appearing with
<A HREF="kdu$cinct__open_block.html">kdu_precinct::open_block</A> and 
<A HREF="kdu$cinct__close_block.html">kdu_precinct::close_block</A>.
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="ArgS">Arguments</A></H2><DIV CLASS="indented-text">
<H4><A NAME="block_idx">block_idx</A> [<A HREF ="kdu_coords.html">kdu_coords</A>]</H4><DIV CLASS="indented-text">
<P>
Must provide indices inside the valid region identified
by the 
<A HREF="kdu$bband__get$id_blocks.html">get_valid_blocks</A> function.
</P>
</DIV>
<H4><A NAME="return_tpart">return_tpart</A> [<B>int</B>&nbsp;*]</H4><DIV CLASS="indented-text">
<P>
For input codestreams, this argument (if not NULL)
is used to return the index of the tile-part to which
the block belongs (starting from 0). For interchange
and output codestreams, a negative number will usually
be returned via this argument if it is used.
</P>
</DIV>
<H4><A NAME="env">env</A> [<A HREF ="kdu$d_env.html">kdu_thread_env</A>&nbsp;*]</H4><DIV CLASS="indented-text">
<P>
You must supply a non-NULL 
<A HREF="kdu$bband__open_block.html#env">env</A> reference if there is any chance that this codestream
(or any other codestream with which it shares storage
via 
<A HREF="kdu$tream__sha$buffering.html">kdu_codestream::share_buffering</A>) is being simultaneously accessed from another thread.
When you do supply a non-NULL 
<A HREF="kdu$bband__open_block.html#env">env</A> argument, the returned block is actually part of the
local storage associated with the thread itself, so
each thread may have a separate open block.
</P><P>
 Note that a non-NULL 
<A HREF="kdu$bband__open_block.html#env">env</A> pointer is unique to the calling thread &mdash; in
most cases 
<A HREF="kdu$bband__open_block.html#env">env</A> points to the 
<A HREF="kdu$d_env.html">kdu_thread_env</A> object that was explicitly created and the calling
thread is the thread-group owner (the one that created
it, unless you have explicitly invoked 
<A HREF="kdu$ntity__cha$er_thread.html">kdu_thread_entity::change_group_owner_thread</A>). Otherwise, 
<A HREF="kdu$bband__open_block.html#env">env</A> identifies a worker thread that was added to the thread
group &mdash; in this case, the worker thread is executing
a scheduled job from which this function is being called.
</P>
</DIV>
<H4><A NAME="hscan_length">hscan_length</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
<P>
From KDU-7.5, this optional argument provides a mechanism
that can be used to reduce the number of bus-locking
atomic synchronization primatives that are required
during regular compression/decompression activities.
</P><P>
 If 
<A HREF="kdu$bband__open_block.html#hscan_length">hscan_length</A> &gt;= 1, the caller is declaring that there will be
<A HREF="kdu$bband__open_block.html#hscan_length">hscan_length</A> calls to this function (including the current call),
with intervening calls to 
<A HREF="kdu$bband__close_block.html">close_block</A>, in which each successive call passes 
<A HREF="kdu$bband__open_block.html#block_idx">block_idx</A> values that are horizontally adjacent, with the 
<A HREF="kdu_coords.html#x">kdu_coords::x</A> coordinate increasing monotonically up to 
<A HREF="kdu_coords.html#x">block_idx.x</A>+
<A HREF="kdu$bband__open_block.html#hscan_length">hscan_length</A>-1. On the first such call, you should pass 
<A HREF="kdu$bband__open_block.html#hscan_start">hscan_start</A>=true, which forces internal state information managed
within the 
<A HREF="kdu_block.html">kdu_block</A> structure to be reset. If you fail to do this, you
may encounter problems if processing is interrupted
unexpectedly, tiles are closed, etc., and then processing
is started up again.
</P>
</DIV>
<H4><A NAME="hscan_start">hscan_start</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
<P>
If true, or 
<A HREF="kdu$bband__open_block.html#hscan_length">hscan_length</A> &lt;= 0, the internal state information used to implement
the 
<A HREF="kdu$bband__open_block.html#hscan_length">hscan_length</A> feature is reset. The safest practice is to pass true
for this argument when opening the first code-block
of a horizontal sequence, passing the remaining sequence
length in for the 
<A HREF="kdu$bband__open_block.html#hscan_length">hscan_length</A> argument. For an example, we recommend you consult
the implementation of the 
<B>kd_decoder::process_blocks</B> and 
<B>kd_encoder::process_blocks</B> functions.
</P>
</DIV>
</DIV>

<P ALIGN="CENTER"><HR></P><P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$bband__det$_notifier.html"> prev </A>||<A HREF="kdu$bband__close_block.html"> next </A>|</P>
</BODY>
</HTML>
