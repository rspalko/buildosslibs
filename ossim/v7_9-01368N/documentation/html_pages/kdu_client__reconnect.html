<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (kdu_client::reconnect) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
.function-text { padding-left: 80pt;
                 text-indent: -60pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#B4DCB4">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ReturnS"> return value </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu_client__aug$che_file.html"> prev </A>||<A HREF="kdu_client__is_$eractive.html"> next </A>|</P>
<H1><A NAME="ToP">kdu_client::reconnect</A></H1>
<DIR><DIR><H3><EM><U>Java:</U> Kdu_client.Reconnect</EM></H3></DIR></DIR>
<P CLASS="function-text">virtual <B>int</B> reconnect(
<B>const char *</B>&nbsp;channel_transport,
<B>const char *</B>&nbsp;proxy,
<B>bool</B>&nbsp;clear_cache=false)</P>
<DIR><DIR><P CLASS="function-text"><EM><U>Java:</U> public native int Reconnect(
String&nbsp;channel_transport,
String&nbsp;proxy,
boolean&nbsp;clear_cache)</EM></P></DIR></DIR>
<P><A HREF="kdu_client.html">Go to class description.</A></P>

<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
This function can be used in place of 
<A HREF="kdu_client__connect.html">connect</A> after a call to 
<A HREF="kdu_client__disconnect.html">disconnect</A>, with no intervening call to 
<A HREF="kdu_client__close.html">close</A>. The 
<A HREF="kdu_client__reconnect.html">reconnect</A> function can be used even if 
<A HREF="kdu_client__disconnect.html">disconnect</A> has not been explicitly called, which can be useful
if the server itself has disconnected the client in
one way or another. If the client and server are still
connected, this function does nothing and the client
remains connected to the server.
</P><P>
 The main differences between 
<A HREF="kdu_client__reconnect.html">reconnect</A> and 
<A HREF="kdu_client__connect.html">connect</A> are as follows:
</P><UL><LI>
<A HREF="kdu_client__reconnect.html">reconnect</A> does not implicitly call 
<A HREF="kdu_client__close.html">close</A>, so it does not lose the contents of the cache accumulated
from a previous connection, although this behaviour
can be overridden by passing 
<A HREF="kdu_client__reconnect.html#clear_cache">clear_cache</A>=true. If you have saved the cache contents then 
<A HREF="kdu_client__connect.html">connect</A> can be used to achieve the same result by reloading
the cache, but 
<A HREF="kdu_client__reconnect.html">reconnect</A> bypasses the otherwise unnecessary load/save steps.
</LI><LI>
<A HREF="kdu_client__reconnect.html">reconnect</A> does not need to be informed of the connection details
(server, request, etc.), since it already knows them.
</LI><LI>
<A HREF="kdu_client__reconnect.html">reconnect</A> can be used to re-establish a connection with the
original server discovered from a cache file passed
to 
<A HREF="kdu_client__ope$che_file.html">open_with_cache_file</A>.
</LI><LI>
<A HREF="kdu_client__reconnect.html">reconnect</A> also knows the exact path of any cache file that was
discovered by 
<A HREF="kdu_client__connect.html">connect</A> or 
<A HREF="kdu_client__ope$che_file.html">open_with_cache_file</A> &mdash; this is a file within the cache directory
that may have been supplied to 
<A HREF="kdu_client__connect.html">connect</A> or 
<A HREF="kdu_client__ope$che_file.html">open_with_cache_file</A>. This is the cache file that will be updated if the
reconnection is successful and the client is configured
to save cache contents.
</LI><LI>
<A HREF="kdu_client__reconnect.html">reconnect</A> uses the internally recorded JPIP target-id to make
sure that the new connection involves exactly the same
representation of the target resource, corresponding
to the existing cache contents. If the server cannot
guarantee consistency, and 
<A HREF="kdu_client__reconnect.html#clear_cache">clear_cache</A> is false, the reconnection necessarily fails, resulting
in an error message being generated (eventually) through
<A HREF="kdu_error.html">kdu_error</A>, after which the 
<A HREF="kdu_client__tar$mpatible.html">target_incompatible</A> function will return true; this does not stop you
from continuing to use the existing cache, but it does
cause the reconnection attempt to fail. One reasonable
action to take after such a condition is discovered
would be to call this function again with 
<A HREF="kdu_client__reconnect.html#clear_cache">clear_cache</A>=true, so that the server's current version of the
target can be accessed from scratch. By contrast, if
<A HREF="kdu_client__connect.html">connect</A> has an existing cache file for a resource, but disconvers
a target-id inconsistency, the existing cache file
is not loaded, but the connection is established.
</LI></UL>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="ReturnS">Return Value</A></H2><DIV CLASS="indented-text">
<P>
If no error occurs, the function will return 0, which
can also be interpreted as the first queue-id, as with
the 
<A HREF="kdu_client__connect.html">connect</A> function. Unlike 
<A HREF="kdu_client__connect.html">connect</A>, however, the function may return other values, as
follows:
</P><UL><LI>
-1 means that the object is already connected, so nothing
needed to be done.
</LI><LI>
-2 means that insufficient information is available
to initiate a connection request &mdash; e.g., neither
<A HREF="kdu_client__connect.html">connect</A> nor 
<A HREF="kdu_client__ope$che_file.html">open_with_cache_file</A> might have been successfully called, or there may
have been an intervening 
<A HREF="kdu_client__close.html">close</A> call.
</LI><LI>
-3 means that a previous attempt to 
<A HREF="kdu_client__reconnect.html">reconnect</A> found an incompatible TARGET-ID and 
<A HREF="kdu_client__reconnect.html#clear_cache">clear_cache</A> is false, so there is no point in trying again; note
that in this case, 
<A HREF="kdu_client__tar$mpatible.html">target_incompatible</A> would also have returned true before this function
was called and will continue to return true.
</LI><LI>
Other negative values may be used to indicate that
the function was able to determine immediately that
reconnection is not possible.
</LI></UL><P>
 As with 
<A HREF="kdu_client__connect.html">connect</A>, the function may generate an error through 
<A HREF="kdu_error.html">kdu_error</A> is something is clearly wrong (e.g., invalid transport
string), which will usually result in an exception
being thrown.
</P>
</DIV>
<H2><A NAME="ArgS">Arguments</A></H2><DIV CLASS="indented-text">
<H4><A NAME="channel_transport">channel_transport</A> [<B>const char *</B>]</H4><DIV CLASS="indented-text">
<P>
During reconnection, you have the opportunity to request
a different type of transport. The interpretation of
this argument is identical to its namesake in 
<A HREF="kdu_client__connect.html">connect</A>, except that a NULL 
<A HREF="kdu_client__reconnect.html#channel_transport">channel_transport</A> argument does not mean that communication should be
stateless; instead, it means that the same type of
transport should be requested as the one that was used
when the client was last connected. Stateless is the
default only if the client was previously communicating
statelessly or has never been connected (i.e., if it
was activated using 
<A HREF="kdu_client__ope$che_file.html">open_with_cache_file</A>).
</P>
</DIV>
<H4><A NAME="proxy">proxy</A> [<B>const char *</B>]</H4><DIV CLASS="indented-text">
<P>
During 
<A HREF="kdu_client__reconnect.html">reconnect</A> you also have the opportunity to set a proxy server
or change the one that might previously have been in
use. If this argument is NULL, the proxy settings remain
unchanged from those established by the last call to
<A HREF="kdu_client__connect.html">connect</A> (no proxy if 
<A HREF="kdu_client__ope$che_file.html">open_with_cache_file</A> was used to get to this point).
</P>
</DIV>
<H4><A NAME="clear_cache">clear_cache</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
<P>
This option is provided mainly to deal with the situation
in which a previous attempt to 
<A HREF="kdu_client__reconnect.html">reconnect</A> resulted in the 
<A HREF="kdu_client__tar$mpatible.html">target_incompatible</A> connection. If this happens, you can continue using
the existing cache, backed by any cache file that may
exist. However, to access the server's current version
of the content, you need to clear the cache and start
from scratch. There are two ways you can do this:
</P><UL><LI>
Use 
<A HREF="kdu_client__connect.html">connect</A> to start again &mdash; this will automatically clear
existing cache contents; or
</LI><LI>
Call this function with 
<A HREF="kdu_client__reconnect.html#clear_cache">clear_cache</A>=true.
</LI></UL><P>
 The advantages of the second approach are as follows:
</P><UL><LI>
The connection and resource details need not be specified
explicitly when calling the present function.
</LI><LI>
If there is a backing cache file, this function knows
exactly which file that is and its lack of compatibility,
which allows it to overwrite the file with new content
received from the server once a connection is established.
On the other hand, 
<A HREF="kdu_client__connect.html">connect</A> just skips over any incompatible cache file, since
there may be many cache files that refer to resources
with the same name that should not necessarily be deleted
or overwritten. The result is that simply calling 
<A HREF="kdu_client__connect.html">connect</A> after discovering incompatibility within a 
<A HREF="kdu_client__reconnect.html">reconnect</A> call may tend pollute the cache directory with out-of-date
content.
</LI></UL><P>
 Note that since this option completely clears the
cache, it is important that you do not have any other
entities reading from it, including asynchronous readers
that might be using caches that are attached to this
one via 
<A HREF="kdu_cache__attach_to.html">kdu_cache::attach_to</A>.
</P>
</DIV>
</DIV>

<P ALIGN="CENTER"><HR></P><P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ReturnS"> return value </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu_client__aug$che_file.html"> prev </A>||<A HREF="kdu_client__is_$eractive.html"> next </A>|</P>
</BODY>
</HTML>
