<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (kdu_stripe_compressor::get_set_next_queue_sequence) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
.function-text { padding-left: 80pt;
                 text-indent: -60pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#B4DCB4">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ReturnS"> return value </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$1essor__start.html"> prev </A>||<A HREF="kdu$1essor__finish.html"> next </A>|</P>
<H1><A NAME="ToP">kdu_stripe_compressor::get_set_next_queue_sequence</A></H1>
<DIR><DIR><H3><EM><U>Java:</U> Kdu_stripe_compressor.Get_set_next_queue_sequence</EM></H3></DIR></DIR>
<P CLASS="function-text"><B>kdu_long</B> get_set_next_queue_sequence(
<B>kdu_long</B>&nbsp;min_val)</P>
<DIR><DIR><P CLASS="function-text"><EM><U>Java:</U> public native long Get_set_next_queue_sequence(
long&nbsp;min_val)</EM></P></DIR></DIR>
<P><A HREF="kdu$1essor.html">Go to class description.</A></P>

<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
This function is provided to support advanced multi-threading
functionality, where multiple 
<A HREF="kdu$1essor.html">kdu_stripe_compressor</A> objects may be sharing a 
<A HREF="kdu$d_env.html">kdu_thread_env</A>. Internally, multi-threaded processing instantiates
and attaches 
<A HREF="kdu$2queue.html">kdu_thread_queue</A> objects to the thread-group identified to 
<A HREF="kdu$1essor__start.html">start</A> via the 
<B>env</B> argument, assigning them sequence indices that are
monotonically increasing (see 
<B>kdu_thread_entity::attach</B> for a detailed explanation of thread-queue sequence
indices). For single tile images there will only ever
be one queue instantiation and attachment, while for
multi-tile images there may be many (the number depends
in part upon 
<B>env_tile_concurrency</B>). Each such queue is assigned a higher thread-queue
sequence index than the last one so that threads will
not process the jobs associated with later queues unless
there are no jobs left to run from earlier queues.
This helps to keep processing running sequentially
while avoiding any thread idle time.
</P><P>
 While the strategy described above works wonderfully
for a single stripe-compressor, in some cases (especially
video) you may have a second stripe-compressors whose
internal queues you would like to continue the sequence
numbering used by a first stripe-compressor; this ensures
that threads will move seamlessly across to do work
scheduled by the second stripe-compressor, as available
jobs drie up within the first. This is exactly what
one needs for video compression and related applications
to run with absolute maximum efficiency.
</P><P>
 To achieve this objective, one would push all stripes
into the first stripe-compressor, then invoke this
function on the first stripe-compressor to determine
the next queue sequence index that it would have used
(the return value), passing that value into the second
stripe-compressor's 
<A HREF="kdu$1essor__get$sequence.html">get_set_next_queue_sequence</A> function as its 
<A HREF="kdu$1essor__get$sequence.html#min_val">min_val</A> argument. Typically, one would schedule a background
processing job to invoke the first stripe-compressor's
<A HREF="kdu$1essor__finish.html">finish</A> function asynchronously while pushing stripe data
into the second stripe-compressor, and so forth. To
see a good example of this, refer to the "kdu_vcom_fast"
demo app.
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="ReturnS">Return Value</A></H2><DIV CLASS="indented-text">
<P>
The thread-queue sequence index that the current object
would use when it next creates and attaches an internal
thread queue to manage tile processing, ignoring any
change that might be induced by the 
<A HREF="kdu$1essor__get$sequence.html#min_val">min_val</A> argument. Thread queues are created and attached only
from within calls to 
<A HREF="kdu$1essor__push_stripe__1.html">push_stripe</A>, so there will be no further queues created if all
sample data has already been pushed in.
</P>
</DIV>
<H2><A NAME="ArgS">Arguments</A></H2><DIV CLASS="indented-text">
<H4><A NAME="min_val">min_val</A> [<B>kdu_long</B>]</H4><DIV CLASS="indented-text">
<P>
Minimum value that the current object will use when
it next needs to create and attach an internal thread
queue to manage tile processing &mdash; this happens
inside calls to 
<A HREF="kdu$1essor__push_stripe__1.html">push_stripe</A>, unless all stripes have already been pushed in, in
which case 
<A HREF="kdu$1essor__get$sequence.html#min_val">min_val</A> does not really matter.
</P><P>
 If the object's next thread-queue sequence index is
already larger than 
<A HREF="kdu$1essor__get$sequence.html#min_val">min_val</A>, no change is made &mdash; the caller can, of course,
detect this by comparing 
<A HREF="kdu$1essor__get$sequence.html#min_val">min_val</A> with the function's return value.
</P><P>
 We consider the object's next thread-queue sequence
index 
<B>val</B> to be smaller than 
<A HREF="kdu$1essor__get$sequence.html#min_val">min_val</A> if (
<B>val</B>-
<A HREF="kdu$1essor__get$sequence.html#min_val">min_val</A>) is a negative integer of type 
<B>kdu_long</B>. That is, a change is made so long as addition of
a positive integer to the object's next sequence index
can carry it to 
<A HREF="kdu$1essor__get$sequence.html#min_val">min_val</A>, taking numerical overflow into account. This definition
ensures that things work correctly even if sequence
indices wrap-around within the precision afforded by
the 
<B>kdu_long</B> data type.
</P>
</DIV>
</DIV>

<P ALIGN="CENTER"><HR></P><P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ReturnS"> return value </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$1essor__start.html"> prev </A>||<A HREF="kdu$1essor__finish.html"> next </A>|</P>
</BODY>
</HTML>
