<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (kdu_quality_limiter::kdu_quality_limiter) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
.function-text { padding-left: 80pt;
                 text-indent: -60pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#B4DCB4">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$miter__~kd$y_limiter.html"> next </A>|</P>
<H1><A NAME="ToP">kdu_quality_limiter::kdu_quality_limiter</A></H1>
<DIR><DIR><H3><EM><U>Java:</U> Kdu_quality_limiter.Kdu_quality_limiter</EM></H3></DIR></DIR>
<P CLASS="function-text"> kdu_quality_limiter(
<B>float</B>&nbsp;weighted_rmse,
<B>bool</B>&nbsp;preserve_if_reversible=true)</P>
<DIR><DIR><P CLASS="function-text"><EM><U>Java:</U> public native  Kdu_quality_limiter(
float&nbsp;weighted_rmse,
boolean&nbsp;preserve_if_reversible)</EM></P></DIR></DIR>
<P><A HREF="kdu$miter.html">Go to class description.</A></P>

<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
Before passing a 
<A HREF="kdu$miter.html">kdu_quality_limiter</A> object to 
<A HREF="kdu$tream__app$trictions__1.html">kdu_codestream::apply_input_restrictions</A>, it is only necessary to invoke the constructor, but
the 
<A HREF="kdu$miter__set$esolution.html">set_display_resolution</A> and 
<A HREF="kdu$miter__set$comp_info.html">set_comp_info</A> functions may be used to provide additional configuration
parameters. Some higher level classes, such as 
<A HREF="kdu$sitor.html">kdu_region_compositor</A>, call those functions for you.
</P><P>
 The interpretation of 
<A HREF="kdu$miter__kdu$y_limiter.html#weighted_rmse">weighted_rmse</A> is easiest to understand when there are no visual
or component weights, meaning that 
<A HREF="kdu$miter__set$esolution.html">set_display_resolution</A> and 
<A HREF="kdu$miter__set$comp_info.html">set_comp_info</A> are not called, or they are invoked with parameters
that identify no additional weighting. In this simple
case 
<A HREF="kdu$miter__kdu$y_limiter.html#weighted_rmse">weighted_rmse</A> is interpreted as a bound on the root-mean-squared
reconstruction error that we are prepared to tolerate
in the output image component samples, expressed with
respect to unit nominal range samples (0 to 1 or -0.5
to 0.5). Specifically, if R is the value of 
<A HREF="kdu$miter__kdu$y_limiter.html#weighted_rmse">weighted_rmse</A>, the total squared error distortion D, over all samples
of all relevant output image components, is to be bounded
by
</P><UL><LI>
D &lt;= R^2 * A_hires * \sum_{c} 1/(Sx_c * Sy_c) =
R^2 * \sum_{c} A_c
</LI></UL><P>
 where A_hires is the area of the image on the codestream's
high resolution canvas, Sx_c and Sx_y are the component
sub-sampling factors, and A_c is the area of the image
within component c. Note that the average represented
by R^2 is over all actual samples, so that more heavily
sub-sampled components have a reduced contribution.
Note that c ranges from 0 to C-1 in the above sum,
where C is the number of relevant output components.
</P><P>
 D can be expanded as a sum of contributions from codestream
component distortions, denoted D_s, as:
</P><UL><LI>
D = \sum_{c} \sum_{s} D_s * (M_cs)^2, where s ranges
over all relevant codestream components and M_cs is
the contribution from codestream component s to output
component c in the linear multi-component synthesis
transform.
</LI></UL><P>
 Finally, each D_s can be expanded as a sum of distortion
contributions from each sample n in each of its subbands
b, yielding
</P><UL><LI>
D = \sum_{c} \sum_{s} (M_cs)^2 \sum_{b,n} D_sbn G_sb
where G_sb is the subband synthesis energy gain factor
for band b of codestream image component s.
</LI></UL><P>
 More generally, we introduce component weighting factors
W_c and spatial (visual) weighting factors W_sb to
the above equations, yielding:
</P><UL><LI>
D = \sum_{s,b,n} D_sbn G_sb (W_bn)^2 [\sum_c (W_c)^2
(M_cs)^2] [\\] or D = \sum_{s,b,n} D_sbn g_sbn, where
g_sbn represents the combined gain factor g_sbn = G_sb
(W_bn)^2 [\sum_c (W_c)^2 (M_cs)^2]. Thus we have
</LI><LI>
\sum_{s,b,n} D_sbn g_sbn &lt;= R^2 \sum_{c} N_c
</LI></UL><P>
 At sufficiently high bit-rates, the rate-distortion
optimal solution to the distortion assignment problem
should yield
</P><UL><LI>
D_sbn = Q / g_sbn for all s, b and n and some Q &gt;
0
</LI></UL><P>
 with the inequality approaching an equality. It follows
that:
</P><UL><LI>
Q = R^2 * [\sum_{c} N_c] / [\sum_{s} N_s], where N_s
= A_hires / (Sx_s * Sy_s) is the total image area associated
with codestream component s. Equivalently,
</LI><LI>
Q = R^2 * [\sum_{c} 1/(Sx_c*Sy_c)] / [\sum_{s} 1/(Sx_s*Sy_s)].
Note that Q may potentially vary from tile to tile
if tile-specifiy Part-2 multi-component transforms
are used, but this would be highly unusual!
</LI></UL><P>
 Together, these equations define a target squared
error distortion D_sbn for each subband, which can
be achieved by discarding coding passes (and hence
bit-planes) until the effective quantization step size
is no larger than
</P><UL><LI>
\Delta_sb = sqrt(12*D_sbn) = sqrt(12Q/g_sbn)
</LI></UL><P>
 In practice, when a 
<A HREF="kdu$miter.html">kdu_quality_limiter</A> object is passed to 
<A HREF="kdu$tream__app$trictions__1.html">kdu_codestream::apply_input_restrictions</A>, it maximum number of coding passes for any code-block
in subband b or codestream component s is constrained
based on the following considerations:
</P><UL><LI>
The last magnitude refinement pass to be decoded should
have an effective step size of 0.5*\Delta_sb &lt; delta
&lt;= \Delta_sb; this ensures that the step size is
no larger than \Delta_sb if any truncation occurs.
</LI><LI>
The last cleanup pass to be decoded should have an
effective quantization step size that lies in the range
0.625*\Delta_sb &lt; delta &lt;= 1.25*\Delta_sb. The
assumption here is that most cleanup samples remain
insignificant and that their distribution is heavily
skewed towards zero, so that the expected distortion
for samples that lie within the deadzone is significantly
less than delta^2/12. Suppose the ratio between non-zero
to zero samples after processing by the cleanup pass
is alpha &lt;&lt; 1 and that the cleanup samples have
a Laplacian distribution. It is interesting to consider
what value of alpha makes the expected distortion equal
to \Delta_sb^2/12 where the step size is delta=1.25*\Delta_sb.
Without loss of generality, let delta=1 and suppose
the Laplacian distribution is proportional to e^{-bx}
for some b. It is easy to see that alpha = e^{-b},
and so our condition is that [D(0) + alpha*D(1)]/(1+alpha)
= 1 / (1.25^2 * 12), where D(0) and D(1) are the expected
distortions given that quantized sample is zero and
non-zero, respectively. We have D(0) = [\int_{0}^{1}
x^2 e^{-bx}dx] / [\int_{0}^{1} e^{-bx}dx] D(1) = [\int_{1}^{2}
x^2 e^{-bx}dx] / [\int_{1}^{2} e^{-bx}dx] - m(1)^2
+ (1.5 - m(1))^2 where m(1) is the condional mean [\int_{1}^{2}
xe^{-bx}dx] / [\int_{1}^{2} e^{-bx}dx]. Putting these
together, we find that the expected distortion becomes
1 / (1.25^2 * 12) at around b=6, corresponding to alpha
= 1/40. That is, we are assuming that about 1 in 40
of the cleanup samples become significant; this is
reasonably consistent with what we find at moderate
quality levels in a JPEG2000 image.
</LI><LI>
The last significance propagation pass to be decoded
should have an effective step size delta that lies
in the range 0.35*\Delta_sb &lt; delta &lt;= 0.7*\Delta_sb.
The situation here is similar to the cleanup pass,
but samples are much more likely to become significant
in the significance propagation pass. Adopting the
same assumptions as above, with a Laplacian distribution
with parameter b, we find that the expected distortion
associated with a step size of delta=1 equals 1 / (0.7^2
* 12) at around b=2, corresponding to alpha = 0.12,
so roughly 1/8 of the samples in the significance propagation
pass are assumed to become significant. This is reasonably
consistent with what typically happens at moderate
quality levels.
</LI></UL><P>
 The above conditions yield separate truncation points
for each of the coding passes, which tends to smooth
the operational complexity-distortion function that
is achieved by sweeping the R parameter. The truncation
conditions have the same ordering as the coding passes
themselves, so any of the coding passes may turn out
to be the trunation point for any given subband, depending
on the value of R.
</P><P>
 We finish this discussion with a few notes on weighting.
The component weights W_c may be used to adjust the
interpretation of the 
<A HREF="kdu$miter__kdu$y_limiter.html#weighted_rmse">weighted_rmse</A> bound to take into account the display interpolation
of image components that may be sub-sampled at the
codestream level. A typical example is 4:2:0 video
where chrominance components are subsampled by 2 in
each directly, relative to luminance. During display,
these chrominance components are upsampled, and so
the true total distortion of interest is D = D_0 +
4D_1 + 4D_2 and we would like this distortion to be
no larger than R^2*A_hires*3. This can be achieved
by setting (W_0)^2=1/2, (W_1)^2=2 and (W_2)^2=2. More
generally, if you intend to interpolate component c
by a factor of Ix_c*Iy_c (i.e., Ix_c horizontally and
Iy_c vertically) and want 
<A HREF="kdu$miter__kdu$y_limiter.html#weighted_rmse">weighted_rmse</A> to represent the RMSE of the interpolated result,
you can use the component weighting equation:
</P><UL><LI>
(W_c)^2 = Ix_c * Ix_y * F where
</LI><LI>
F = (\sum_c N_c) / (\sum_j N_c*Ix_c*Iy_c)). Equivalently,
</LI><LI>
F = (\sum_c 1/(Sx_c*Sy_c)) / (\sum_c (Ix_c*Iy_c)/(Sx_c*Sy_c))
</LI></UL><P>
 The role of spatial (or visual) weights is to reflect
the fact that distortion in higher frequency components
may be significantly attenuated by the display MTF
and/or human visual sytem CSF (contrast sensitivity
function). Generally, these weights W_sb should be
1 for lower frequency subbands. By default, the 
<A HREF="kdu$miter__get$al_weight.html">get_square_visual_weight</A> function returns 1.0 for all subbands, but this behaviour
is modified by calling 
<A HREF="kdu$miter__set$esolution.html">set_display_resolution</A>. The present object has a built-in set of assumptions
concerning visual sensitivity that depend upon the
display resolutions supplied to 
<A HREF="kdu$miter__set$esolution.html">set_display_resolution</A> (if called). However, it is expected that some applications
may provide custom overrides of the 
<A HREF="kdu$miter.html">kdu_quality_limiter</A> class that include more sophisticated visual models.
</P><P>
 It is worth noting that this object does not provide
any means to directly specify separate sets of visual
weights for each codestream component s. Visual weights
(actually their squares) are retrieved using the 
<A HREF="kdu$miter__get$al_weight.html">get_square_visual_weight</A> function, which does not actually take a codestream
component index. It does, however, take arguments that
identify the component sub-sampling factors and whether
or not the component is believed to represent chroma-type
information, which may affect the visibility of distortion
artefacts.
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="ArgS">Arguments</A></H2><DIV CLASS="indented-text">
<H4><A NAME="weighted_rmse">weighted_rmse</A> [<B>float</B>]</H4><DIV CLASS="indented-text">
<P>
Notionally this parameter should be interpreted as
an upper bound on the root-mean-squared error of the
reconstructed imagery. Where there are weights, these
are best interpreted as modeling a filtering process
that attenuates some of the distortion before it gets
sensed, so the RMSE interpretation is still meaningful.
In practice the actual RMSE tends to be smaller than
the supplied parameter, but not usually by more than
a factor of 2. A conservative choice for this parameter
for 8-bit displays is 1/256 (i.e., about 0.004).
</P><P>
 Indeed our studies show that this choice usually produces
distortions that are near impossible to detect visually.
Coupling this with visual weights induced by a sensible
choice of display resolution (see 
<A HREF="kdu$miter__set$esolution.html">set_display_resolution</A>) usually results in both high visual quality and substantial
decompression speedups at reduced resolutions &mdash;
of course, the visual quality is still limited by the
original compressed content.
</P>
</DIV>
<H4><A NAME="preserve_if_reversible">preserve_if_reversible</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
<P>
If true, quality limiting will be applied only to content
that was compressed non-reversibly, or where the 
<B>discard_levels</B> parameter to 
<A HREF="kdu$tream__app$trictions__1.html">kdu_codestream::apply_input_restrictions</A> is non-zero. Irreversibly compressed content cannot
generally be lossless and the same applies to content
reconstructed from a reduced set of DWT levels, so
it is totally reasonable to tune the distortion to
match what can be seen at the relevant rendering resolution.
Leaving lossless content untouched at full resolution
seems the safest option, since there may be some domains
(e.g. medical imagery) where failure to decompress
lossless content without any numerical distortion might
create legal liability. From a subjective/aesthetic
point of view, however, there is no good reason why
quality limitation should not also be applied to the
reconstruction of reversibly compressed content, and
this could yield very substantial increases in throughput.
</P>
</DIV>
</DIV>

<P ALIGN="CENTER"><HR></P><P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu$miter__~kd$y_limiter.html"> next </A>|</P>
</BODY>
</HTML>
